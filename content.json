{"pages":[],"posts":[{"title":"axios封装","text":"首先安装axios npm install axios --save 导入axios const axios = require('axios') 配置axios 12axios.defaults.baseURL = 'http://127.0.0.1:8000/'axios.defaults.timeout = 10000 封装axios的四种请求方式 GET 123456789export function get(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.get(url, {params, headers}).then(res =&gt; { resolve(res) }).catch(err =&gt; { reject(err) }) })} POST 12345678910export function post(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.post(url, params, headers).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} PUT 12345678910export function put(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.put(url, params, headers).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} DELETE 12345678910export function del(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.delete(url, {data: params, headers}).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} 调用方式 1234get({ url: 'index/', data}).then().catch()","link":"/zhengboke/2021/03/19/axios%E5%B0%81%E8%A3%85/"},{"title":"docker","text":"安装依赖 12yum -y install gccyum -y install gcc-c++ 卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 安装docker yum install docker-ce 启动docker systemctl start docker 下载镜像 docker pull centos 运行容器 docker run centos echo &quot;hello word&quot; 运行容器指定容器 docker run hello-world 镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。 Docker国内镜像： 网易加速器：http://hub-mirror.c.163.com官方中国加速器：https://registry.docker-cn.comustc的镜像：https://docker.mirrors.ustc.edu.cn也可使用私人镜像加速器地址，如使用阿里云的镜像加速器：登录阿里云-&gt;产品-&gt;搜索”容器镜像服务”-&gt;镜像库-&gt;镜像加速器。 新版的 Docker 使用 /etc/docker/daemon.json（Linux） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： 1234vi /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;] } 配置成功后，CentOS重启： 12systemctl daemon-reload #重启加速配置文件systemctl restart docker #重启docker后台服务","link":"/zhengboke/2021/03/19/docker/"},{"title":"celery异步","text":"安装celery pip install celery 导入celery from celery import Celery 启动celery celery worker -A _tasks.tasks -l info -E 定义celery对象 app = Celery(&quot;taks&quot;, broker=&quot;redis://localhost/1&quot;) 定义队列方法 123@app.task()def function(): print(&quot;我是队列方法&quot;) 调用 function()","link":"/zhengboke/2021/03/19/celery%E5%BC%82%E6%AD%A5/"},{"title":"python向七牛云和又拍云上传文件","text":"--- title: python向七牛云和又拍云上传文件 --- 七牛云七牛云官方文档：https://developer.qiniu.com/kodo/1242/python#rs-stat 首先安装七牛云的官方模块 1234# 直接安装pip install qiniu或easy_install qiniu 12345# 源码安装# 从Python SDK 下载地址下载源码tar xvzf python-sdk-$VERSION.tar.gzcd python-sdk-$VERSIONpython setup.py install 定义七牛云对象 1234from qiniu import Authq = Auth(access_key, secret_key)# access_key 和 secret_key 可以在你的七牛云个人中心中找到 开始上传 12345678910key = '上传后的文件名'bucket_name = '要上传的空间's = 3600 # 指定token过期时间(秒)token = q.upload_token(bucket_name, key, )localfile = '本地文件路径'ret, info = put_file(token, key, localfile)print(info) 又拍云又拍云官方文档： http://docs.upyun.com/api/sdk/#python-sdk 安装又拍云官方模块 pip install upyun 初始化对象 12345# 包含文件import upyun# 创建实例up = upyun.UpYun('仓库名', '您的操作员名', '您的操作员密码') 123456789/** 参数说明* checksum，表示是否进行 MD5 校验，如果是小文件，建议进行，为 True；如果是大文件，建议不进行，为 False* headers，表示需要的头信息，见 REST API 上传文件*/headers = { 'x-gmkerl-thumb': '/fw/300' }with open('文件地址', 'rb') as f: res = up.put('存到仓库的位置和文件名', f, checksum=True, headers=headers)","link":"/zhengboke/2021/03/19/python%E5%90%91%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/zhengboke/2021/03/19/hello-world/"},{"title":"redis发布者订阅者","text":"Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 实例以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。 在我们实例中我们创建了订阅频道名为 runoobChat: 第一个客户端 123456redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1 现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。 第二个客户端 123456789101112131415redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;(integer) 1# 订阅者的客户端会显示如下消息 1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Redis PUBLISH test&quot; 1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Learn redis by runoob.com&quot; 下面还有redis发布订阅的指令 1 PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 2 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 5 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。 6 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。","link":"/zhengboke/2021/03/19/redis%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/"},{"title":"redis键空间事件","text":"功能概述键空间通知允许客户端订阅发布/订阅频道，以便以某种方式接收影响Redis数据集的事件。可能接收的事件示例如下： 所有影响给定键的命令。所有接收LPUSH操作的键。所有在数据库0中到期的键。事件使用Redis的普通发布/订阅层传递，因此实现了发布/订阅的客户端无需修改即可使用此功能。由于Redis的发布/订阅是fire and forget，因此如果你的应用要求可靠的事件通知，目前还不能使用这个功能，也就是说，如果你的发布/订阅客户端断开连接，并在稍后重连，那么所有在客户端断开期间发送的事件将会丢失。将来有计划允许更可靠的事件传递，但可能会在更一般的层面上解决，要么为发布/订阅本身带来可靠性，要么允许Lua脚本拦截发布/订阅的消息以执行推送等操作，就像往队列里推送事件一样。 事件类型键空间通知的实现是为每一个影响Redis数据空间的操作发送两个不同类型的事件。例如，在数据库0中名为mykey的键上执行DEL操作，将触发两条消息的传递，完全等同于下面两个PUBLISH命令： 12PUBLISH __keyspace@0__:mykey delPUBLISH __keyevent@0__:del mykey 以上很容易看到，一个频道允许监听所有以键mykey为目标的所有事件，以及另一个频道允许获取有关所有DEL操作目标键的信息。第一种事件，在频道中使用keyspace前缀的被叫做键空间通知，第二种，使用keyevent前缀的，被叫做键事件通知。在以上例子中，为键mykey生成了一个del事件。 会发生什么： 键空间频道接收到的消息是事件的名称。键事件频道接收到的消息是键的名称。可以只启用其中一种通知，以便只传递我们感兴趣的事件子集。 配置默认情况下，键空间事件通知是不启用的，因为虽然不太明智，但该功能会消耗一些CPU。可以使用redis.conf中的notify-keyspace-events或者使用CONFIG SET命令来开启通知。将参数设置为空字符串会禁用通知。 为了开启通知功能，使用了一个非空字符串，由多个字符组成，每一个字符都有其特殊的含义，具体参见下表： 1234567891011K 键空间事件，以__keyspace@&lt;db&gt;__前缀发布。E 键事件事件，以__keyevent@&lt;db&gt;__前缀发布。g 通用命令（非类型特定），如DEL，EXPIRE，RENAME等等$ 字符串命令l 列表命令s 集合命令h 哈希命令z 有序集合命令x 过期事件（每次键到期时生成的事件）e 被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）A g$lshzxe的别名，因此字符串AKE表示所有的事件。 字符串中应当至少存在K或者E，否则将不会传递事件，不管字符串中其余部分是什么。例如，要为列表开启键空间事件，则配置参数必须设置为Kl，以此类推。字符串KEA可以用于开启所有可能的事件。 不同的命令生成的事件根据以下列表，不同的命令产生不同种类的事件。 DEL命令为每一个删除的key生成一个del事件。RENAME生成两个事件，一个是为源key生成的rename_from事件，一个是为目标key生成的rename_to事件。EXPIRE在给一个键设置有效期时，会生成一个expire事件，或者每当设置有效期导致键被删除时，生成expired事件（请查阅EXPIRE文档以获取更多信息）。SORT会在使用STORE选项将结果存储到新键时，生成一个sortstore事件。如果结果列表为空，且使用了STORE选项，并且已经存在具有该名称的键时，那个键将被删除，因此在这种场景下会生成一个del事件。SET以及所有其变种（SETEX，SETNX，GETSET）生成set事件。但是SETEX还会生成一个expire事件。MSET为每一个key生成一个set事件。SETRANGE生成一个setrange事件。INCR、DECR、INCRBY、DECRBY命令都生成incrby事件。INCRBYFLOAT生成一个incrbyfloat事件。APPEND生成一个append事件。LPUSH和LPUSHX生成一个lpush事件，即使在可变参数情况下也是如此。RPUSH和RPUSHX生成一个rpush事件，即使在可变参数情况下也是如此。RPOP生成rpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。LPOP生成lpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。LINSERT生成一个linsert事件。LSET生成一个lset事件。LTRIM生成ltrim事件，此外，如果结果列表为空或者键被移除，将会生成一个del事件。RPOPLPUSH和BRPOPLPUSH生成rpop事件和lpush事件。这两种情况下，顺序都将得到保证（lpush事件将总是在rpop事件之后传递）。此外，如果结果列表长度为零且键被删除，则会生成一个del事件。HSET、HSETNX以及HMSET都生成一个hset事件。HINCRBY生成一个hincrby事件。HINCRBYFLOAT生成一个hincrbyfloat事件。HDEL生成一个hdel事件，此外，如果结果哈希集为空或者键被移除，将生成一个del事件。SADD生成一个sadd事件，即使在可变参数情况下也是如此。SREM生成一个srem事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。SMOVE为每一个源key生成一个srem事件，以及为每一个目标key生成一个sadd事件。SPOP生成一个spop事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。SINTERSTORE、SUNIONSTORE、SDIFFSTORE分别生成sinterstore、sunionostore、sdiffstore事件。在特殊情况下，结果集是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。ZINCR生成一个zincr事件。ZADD生成一个zadd事件，即使添加了多个元素。ZREM生成一个zrem事件，即使删除了多个元素。当结果有序集合为空且生成了键，则会生成额外的del事件。ZREMBYSCORE生成一个zrembyscore事件。当结果有序集合为空且生成了键，则会生成额外的del事件。ZREMBYRANK生成一个zrembyrank事件。当结果有序集合为空且生成了键，则会生成额外的del事件。ZINTERSTORE和ZUNIONSTORE分别生成zinterstore和zunionstore事件。在特殊情况下，结果有序集合是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。每次一个拥有过期时间的键由于过期而从数据集中移除时，将生成一个expired事件。每次一个键由于maxmemory策略而被从数据集中驱逐，以便释放内存时，将生成一个evicted事件。重要 所有命令仅在真正修改目标键时才生成事件。例如，使用SREM命令从集合中删除一个不存在的元素将不会改变键的值，因此不会生成任何事件。如果对某个命令如何生成事件有疑问，最简单的方法是自己观察：’ 1234$ redis-cli config set notify-keyspace-events KEA$ redis-cli --csv psubscribe '__key*__:*'Reading messages... (press Ctrl-C to quit)&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1 此时，在另外一个终端使用redis-cli发送命令到Redis服务器，并观察生成的事件： 123&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyspace@0__:foo&quot;,&quot;set&quot;&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyevent@0__:set&quot;,&quot;foo&quot;...","link":"/zhengboke/2021/03/19/redis%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/"},{"title":"vue拦截器的使用","text":"现在的web开发大部分是采用前后端不分离的方式，在前后端不分离的模式下前后端的交互一般是采用axios请求方式来实现。 什么是axios？axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest从 node.js 发出 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防止 CSRF/XSR vue拦截器现在有一个场景，每次请求都要发送token来验证是否登录，但是在每个请求接口都要携带token无疑是十分麻烦，那么有没有一种方式可以让每个请求在发送前都执行某些操作呢？使用vue拦截器就是可以实现 vue拦截器的实现下载axios包 npm install axios --save 在config 中，加入 axios.js 12345678910111213141516171819202122232425# 导入axiosimport axios from 'axios' // 添加请求拦截器axios.interceptors.request.use(function (config) { // 在发送请求前会执行以下代码，这里是判断localStorage中是否存有tokenif (window.localStorage.getItem('token')) { //若token存在则在头部中携带token config.headers.Authorization = window.localStorage.getItem('token');}// 返回请求return config}, function (error) { // 当请求错误时会执行下面的代码，这里是返回错误的信息return Promise.reject(error)}); // 添加响应拦截器，响应拦截器会对相应进行处理axios.interceptors.response.use(function (response) { // 在收到响应后会执行下面的代码，这里是返回响应的信息 return response}, function (error) { // 当响应错误后会执行下面的代码，这里是返回错误信息 return Promise.reject(error)});","link":"/zhengboke/2021/03/19/vue%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"Vue路由钩子","text":"现在有一个场景，当你登录后，你的用户名需要在页面上展示，但是由于你在请求登录成功后没有将用户名存到session中，这样在跳转过去后，会读取到空白，所以这时候就可以使用路由钩子。路由钩子主要作用是拦截导航，可以在跳转前执行一些代码或进行一些判断，来决定完成跳转或者取消跳转。 首先看一下路由钩子的格式 1234567beforeRouteLeave(to,from,next){ if(sessionstorage.getItem('username'){ next(); }else{ next(false); };}; 大概就是这么个格式，参数 to ——是要跳转到的界面，from —— 从哪个界面离开，next() —— 是否允许跳转，如果是 next(false) ——禁止跳转，next({name:login}) —— 跳转到登录界面（需要自己手动配置路由），next()或者 next(true) ——允许跳转。 路由钩子有三种实现方式全局钩子 beforeEach(进入之前触发)、afterEach（进入之后触发） 123456Router.beforeEach((to,from,next)=&gt;{ ......})Router.afterEach((to,from,next)=&gt;{ ......}) 全局钩子会在每次跳转时都会被执行 路由独享钩子 beforeEnter beforeLeave 12345678910routes: [ { path: '/index', name: 'index', component: index, beforeEnter:(to, from, next) =&gt;{ next(); } } ] 路由独享，就是在路由配置中添加即可，只对被配置路由有用 组件内钩子 beforeRouteLeave beforeRouteEnter beforeRouteUpdate 12345methods:{ beforeRouteLeave(to,from,next){ ....... } } 组件内钩子写在methods中即可，从本组件进行的跳转都会触发","link":"/zhengboke/2021/03/19/vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"},{"title":"vue父子组件的传值","text":"父组件向子组件传值 传值 &lt;header :title=&quot;hh&quot;&gt;&lt;/header&gt; 收值 123export default { props: ['title']} 以上就是单向数据流的一般表现了： 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。 子组件向父组件传参父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值。 123456789101112131415161718192021222324&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=&quot;test&quot;&gt; &lt;test-com @childFn=&quot;parentFn&quot;&gt;&lt;/test-com&gt; &lt;br/&gt; 子组件传来的值 : {{message}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { // ... data() { return { message: '' } }, methods: { parentFn(payload) { this.message = payload; } }}&lt;/script&gt; 子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。 1234567891011121314151617181920212223&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=&quot;testCom&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;button @click=&quot;click&quot;&gt;Send&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { // ... data() { return { // 默认 message: '我是来自子组件的消息' } }, methods: { click() { this.$emit('childFn', this.message); } } }&lt;/script&gt;","link":"/zhengboke/2021/03/19/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/"},{"title":"微博三方登录","text":"微博三方登录流程 1.微博三方登录流程 1.1 前端获取认证code 1.在Vue页面加载时 动态发送请求获取微博授权url 2.django收到请求的url后，通过微博 应用ID(client_id)和回调地址(redirect_uri) 动态 生成授 权url返回给Vue 3.当用户点击上面的url进行扫码，授权成功会 跳转我们的回调界面并附加code参数 4.Vue获取到微博返回的code后，会 将code发送给django后端 (上面的redirect_uri) 1.2 获取微博access_token 后端获取code后，结合client_id、client_secret、redirect_uri参数进行传递,获取微博 access_token 1.3 获取微博用户基本信息并保存到数据库 使用获得的access_token调用获取用户基本信息的接口， 获取用户第三方平台的基本信息 用户基本信息 保存到数据库，然后关联本地用户 ，然后将用户信息返回给前端 1.4 生成token给Vue django后端借助微博认证成功后，可以 使用JWT生成token ，返回给Vue Vue将token存储到localStorage中 ，以便用户访问其他页面进行身份验证","link":"/zhengboke/2021/03/19/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"},{"title":"webshell","text":"Vue部分在vue中导入插件 123456import * as attach from 'xterm/lib/addons/attach/attach' // 安装插件适，可以使用attach去添加import * as fit from 'xterm/lib/addons/fit/fit' // fit进行自适应大小的import { Terminal } from 'xterm'Terminal.applyAddon(attach) // 添加插件Terminal.applyAddon(fit) // 添加插件 创建黑窗口组件 123&lt;div id=&quot;terminal&quot;&gt; &lt;!-- 黑窗口--&gt;&lt;/div&gt; 在钩子函数中初始化黑窗口对象 123456789101112131415161718192021mounted() { // 获取到了div标签 let terminalContainer = document.getElementById('terminal') // 初始化黑窗口对象 this.term = new Terminal(this.terminal) // 打开这个对象 this.term.open(terminalContainer) new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket.onopen = function(){ // 连接成功触发该方法 console.log('websocket is Connected...') } this.terminalSocket.onclose = function(){ // 连接关闭适触发的方法 console.log('websocket is Closed...') } this.terminalSocket.onerror = function(){ // 连接出错触发的方法 console.log('damn Websocket is broken!') } this.term.attach(this.terminalSocket) } Django部分导包 1234from dwebsocket import accept_websocketimport timeimport paramikofrom threading import Thread 定义连接函数 12345678910111213141516def make_ssh(host=&quot;127.0.0.1&quot;, username=&quot;root&quot;, password=&quot;123456&quot;): &quot;&quot;&quot; :host 主机地址 :username 用户名，一般是root :password 密码 :port ssh协议的端口,22 &quot;&quot;&quot; # 初始化一个ssh对象 sh = paramiko.SSHClient() # 设置对象连接密钥规则 sh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 连接 sh.connect(host, username=username, password=password, port=22) # 生成shell对象 channle = sh.invoke_shell(term='xterm') return channle 定义接收线程函数 12345678910111213def recv_ssh_msg(channle, ws): ''' 只管接收 ''' # 判断shell连接对象是否没有退出 while not channle.exit_status_ready(): # 接收过程可能会因为没有任何返回而报错 try: buf = channle.recv(1024) # 接收命令的执行结果 ws.send(buf) # 向Websocket通道返回 # 接收不到会报错，但是报错没关系，继续重新尝试接受 except: break 定义连接视图函数 1234567891011121314151617181920@accept_websocketdef webssh(request): if request.is_websocket: # 1. 获取到连接对象 ws = request.websocket # 2. 初始化linux连接 channel = make_ssh() # 3. 初始化linux数据接收线程，并开启 recv_thread = Thread(target=recv_ssh_msg, args=(channel, ws)) recv_thread.start() while 1: # 主线程: 只管发送 # 2. 阻塞ws接收发来的数据 cmd = ws.wait() # cmd = ws.recv() if cmd: channel.send(cmd) # 发送到linux 去执行 else: # 如果连接断开，那么cmd将会发一个空包 break recv_thread.join() # 回收子线程 ws.close() # 关闭ws连接","link":"/zhengboke/2021/03/19/webshell/"},{"title":"支付宝三方支付","text":"一.准备工作 123451. 登录第三方支付宝开放平台 点击链接支付宝开放平台 (https://open.alipay.com/index.htm) 2. 开发前一定要阅读支付宝官方文档中心开发步骤 3. 下载相应的开发工具包（在文档中心&gt;资源下载） 压缩包下的“支付宝钱包支付接口开发包”中即有Andoid使用支付宝的JAR和Demo 二.开发步骤创建支付宝应用（管理中心&gt;我的应用）备注：申请通过后会获得：合作者身份ID（PID），该ID在项目配置中需要用到 完善信息（上传应用图标、说明文档）配置应用环境根据API文档详解进行配置（引用自API文档）第一步 生成RSA密钥特别注意事项（坑点）下载支付宝的官网之后生成你所需要的密钥及PKCS8转码一定要小心 1234567891011121314151617生成方式一（推荐）：使用支付宝提供的一键生成工具（内附使用说明）Windows：下载 （在API文档中点击下载） MAC OSX：下载 解压打开文件夹，直接运行“支付宝RAS密钥生成器 SHAwithRSA1024_V1.0.bat”（WINDOWS） 或“SHAwithRSA1024_V1.0.command”（MACOSX），点 击“生成RSA密钥”，会自动生成公私钥，然后点击“打开文件位 置”，即可找到工具自动生成的密钥。注意：工具不支持含中文或空格的路径，请下载到英文目录下使用。生成方式二：也可以使用OpenSSL工具命令生成（详细参考API）开发者登录开放平台后，找到并进入应用。点击“RSA(SHA1)密钥”处的“设置开发者公钥”（如已设置则显示“查看开发者公钥”，可修改），将公钥文件去除头尾、换行和空格，仅需填入字符串。 例如转换前公钥pem文件格式： 12-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM/CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY/QpkddCVXnZ4bAUaQjXQIDAQAB-----END PUBLIC KEY----- 转换后得到的字符串为： 1MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM/CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY/QpkddCVXnZ4bAUaQjXQIDAQAB 第三步 获取支付宝公钥 1应用上线后点击“查看支付宝公钥”，即可获取支付宝公钥，用于支付宝返回数据的验签。 对于支付宝公钥，看到的是一个字符串，如下： 1MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB 如果需要使用文件方式（如使用服务端SDK的PHP/.NET版本）读取支付宝公钥，需要在头尾加入标示后保存至文件，文件内容如下： 123-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB-----END PUBLIC KEY----- django代码实现 读取公钥私钥 12345#生成的是app_private(私钥)app_private_key_string = open(&quot;alipay/app_private.txt&quot;).read()#生成的是alipay_public(公钥)这个公钥就支付宝的公钥把生成的公钥去沙箱复制到沙箱里面 生成一个支付宝公钥alipay_public_key_string = open(&quot;alipay/alipay_public.txt&quot;).read() 在settings.py中配置支付宝接口 1234567891011#请求支付宝接口alipay = AliPay( appid=&quot;2021000116661399&quot;, app_notify_url=None, # 默认回调url app_private_key_string=app_private_key_string, # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_string=alipay_public_key_string, sign_type=&quot;RSA2&quot;, # RSA 或者 RSA2 debug=True, # 默认False config=AliPayConfig(timeout=15) # 可选, 请求超时时间 ) 请求视图 12345678910# 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_string order_string = alipay.api_alipay_trade_page_pay( out_trade_no=sn, total_amount=total, subject=subject, return_url=&quot;http://www.fan.com:8080/%23/test&quot;, # notify_url=&quot;https://example.com/notify&quot; # 可选, 不填则使用默认notify url ) url = &quot;https://openapi.alipay.com/gateway.do?&quot; + order_string return Response({&quot;url&quot;: url})","link":"/zhengboke/2021/03/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"},{"title":"网页视频直播","text":"首先，安装OBS地址： https://obsproject.com/ 在云主机中安装NGINX 安装nginx 12yum install https://extras.getpagespeed.com/release-el$(rpm -E %{rhel})-latest.rpmyum install nginx-module-flv 1234mkdir /usr/local/nginx-flv# 创建了一个安装目录mkdir /home/flv-tools# 存储所需软件 解压 12tar -zxvf 文件名unzip 文件名 进入解压好的nginx下目录，并进行安装前的配置 1234cd nginx-1.18.0./configure --prefix=/usr/local/nginx-flv --add-module=/home/flv-tools/nginx-http-flv-module-master# --prefix: 配置安装路径#--add-module: 添加安装插件 编译及安装 make &amp;&amp; make install 打开配置文件 vim nginx.conf 配置文件修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647worker_processes 1;rtmp_auto_push on;rtmp_auto_push_reconnect 1s;rtmp_socket_dir /tmp;rtmp{ out_queue 4096; out_cork 8; max_streams 128; timeout 15s; drop_idle_publisher 15s; log_interval 5s; log_size 1m; server { listen 1935; # 推流端口 server_name zege; application live { # 配置推流地址 live on; # 打开推流 # gop_cache on; # rtmp://123.123.123.123:1935/live/test } }}events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8080; # 拉流通过8080去拉流 # http://123.123.123.123:8080/live/?port=1935&amp;stream=test server_name localhost; location /live { flv_live on; chunked_transfer_encoding on; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; } }} 关闭旧有服务 12/usr/local/nginx-rtmp/sbin/nginx -s stop/usr/local/nginx-rtmp/sbin/nginx -s reload 开启新服务 1/usr/local/nginx-flv/sbin/nginx -c /usr/local/nginx-flv/conf/nginx.conf ! 记得在云主机管理中开放1935和8080端口 推流地址 rtmp://云主机地址:1935/live/test 拉流地址 http://云主机地址:8080/live?port=1935&amp;app=live&amp;stream=test Vue实现拉流安装 flv.js开源工具，进行拉流，哔哩哔哩开源的拉流js cnpm install flv.js --save 导包 import flv from 'flv.js'; 定义组件 123&lt;video id=&quot;videoElement&quot; controls muted&gt; Your browser is too old which doesn't support HTML5 video.&lt;/video&gt; 在钩子函数中进行初始化 12345678910111213141516171819mounted() { var videoElement = document.getElementById('videoElement'); var flvPlayer = flv.createPlayer({ type: 'flv', enableWorker: true, //浏览器端开启flv.js的worker,多进程运行flv.js isLive: true, //直播模式 hasAudio: false, //关闭音频 hasVideo: true, // cors: true, stashInitialSize: 128, enableStashBuffer: false, //播放flv时，设置是否启用播放缓存，只在直播起作用。 // url: 'http://192.168.2.234/flv/323223618780001' // url: 'http://39.105.79.238:8080/live?port=1935&amp;app=live&amp;stream=test' url: 'http://47.93.48.154:8080/live?port=1935&amp;app=live&amp;stream=test' }) flvPlayer.attachMediaElement(videoElement); flvPlayer.load(); flvPlayer.play();} 臭不要脸高磊","link":"/zhengboke/2021/03/19/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"},{"title":"无极限自关联查询","text":"views.py 123456789101112131415161718192021222324252627# 无限自关联递归函数def function(id): # 接收id 查询结果集 query = User.objects.filter(uid=id) # 进行序列化 data = UserSer(query, many=True).data # 在序列化结果中添加下一级空列表列表， data['list'] = [] # 遍历结果集，递归调用并将调用结果存入上级列表 for i in data: data['list'].append(functions(i.uid)) # 返回结果集 return dataclass Path(APIView): def get(self, request): # 定义结果集列表 path_list = [] # 查取所有信息 query = Path.objects.all() # 遍历开始递归查询 for i in data: path_list.append(function(i.id)) retrun Response(path_list) models.py 123class Path(models.Model): name = models.CharField(max_leng=50) uid = models.ForeignKey(to='self', on_delete=models.SETNULL, default=None) serializers.py 1234class PathSer(ModelSerializer): class Meta: model = Path fields = '__all__'","link":"/zhengboke/2021/03/19/%E6%97%A0%E6%9E%81%E9%99%90%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"},{"title":"线程和线程池","text":"","link":"/zhengboke/2021/03/19/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"tags":[],"categories":[]}