{"pages":[],"posts":[{"title":"Python正则表达式","text":"title:Python正则表达式正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 本章主要介绍Python中常用的正则表达式处理函数。 re模块主要分三个正则模式,下面会一一讲解re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 语法: re.match(pattern, string, flags=0) pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：文章底下 re.search方法re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(pattern, string, flags=0) pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：文章底下 (注：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。) 正则表达式修饰符 - 可选标志 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\t’)匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [ \\t\\n\\r\\f]。 \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。","link":"/zhengboke/2021/03/23/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"celery异步","text":"安装celery pip install celery 导入celery from celery import Celery 启动celery celery worker -A _tasks.tasks -l info -E 定义celery对象 app = Celery(&quot;taks&quot;, broker=&quot;redis://localhost/1&quot;) 定义队列方法 123@app.task()def function(): print(&quot;我是队列方法&quot;) 调用 function()","link":"/zhengboke/2021/03/19/celery%E5%BC%82%E6%AD%A5/"},{"title":"axios封装","text":"首先安装axios npm install axios --save 导入axios const axios = require('axios') 配置axios 12axios.defaults.baseURL = 'http://127.0.0.1:8000/'axios.defaults.timeout = 10000 封装axios的四种请求方式 GET 123456789export function get(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.get(url, {params, headers}).then(res =&gt; { resolve(res) }).catch(err =&gt; { reject(err) }) })} POST 12345678910export function post(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.post(url, params, headers).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} PUT 12345678910export function put(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.put(url, params, headers).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} DELETE 12345678910export function del(url, params, headers) { return new Promise((resolve, reject) =&gt; { axios.delete(url, {data: params, headers}).then((res) =&gt; { resolve(res) }).catch((err) =&gt; { // debugger reject(err) }) })} 调用方式 1234get({ url: 'index/', data}).then().catch()","link":"/zhengboke/2021/03/19/axios%E5%B0%81%E8%A3%85/"},{"title":"docker","text":"安装依赖 12yum -y install gccyum -y install gcc-c++ 卸载旧版本 yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 安装docker yum install docker-ce 启动docker systemctl start docker 下载镜像 docker pull centos 运行容器 docker run centos echo &quot;hello word&quot; 运行容器指定容器 docker run hello-world 镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。 Docker国内镜像： 网易加速器：http://hub-mirror.c.163.com官方中国加速器：https://registry.docker-cn.comustc的镜像：https://docker.mirrors.ustc.edu.cn也可使用私人镜像加速器地址，如使用阿里云的镜像加速器：登录阿里云-&gt;产品-&gt;搜索”容器镜像服务”-&gt;镜像库-&gt;镜像加速器。 新版的 Docker 使用 /etc/docker/daemon.json（Linux） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： 1234vi /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;] } 配置成功后，CentOS重启： 12systemctl daemon-reload #重启加速配置文件systemctl restart docker #重启docker后台服务","link":"/zhengboke/2021/03/19/docker/"},{"title":"python向七牛云和又拍云上传文件","text":"--- title: python向七牛云和又拍云上传文件 --- 七牛云七牛云官方文档：https://developer.qiniu.com/kodo/1242/python#rs-stat 首先安装七牛云的官方模块 1234# 直接安装pip install qiniu或easy_install qiniu 12345# 源码安装# 从Python SDK 下载地址下载源码tar xvzf python-sdk-$VERSION.tar.gzcd python-sdk-$VERSIONpython setup.py install 定义七牛云对象 1234from qiniu import Authq = Auth(access_key, secret_key)# access_key 和 secret_key 可以在你的七牛云个人中心中找到 开始上传 12345678910key = '上传后的文件名'bucket_name = '要上传的空间's = 3600 # 指定token过期时间(秒)token = q.upload_token(bucket_name, key, )localfile = '本地文件路径'ret, info = put_file(token, key, localfile)print(info) 又拍云又拍云官方文档： http://docs.upyun.com/api/sdk/#python-sdk 安装又拍云官方模块 pip install upyun 初始化对象 12345# 包含文件import upyun# 创建实例up = upyun.UpYun('仓库名', '您的操作员名', '您的操作员密码') 123456789/** 参数说明* checksum，表示是否进行 MD5 校验，如果是小文件，建议进行，为 True；如果是大文件，建议不进行，为 False* headers，表示需要的头信息，见 REST API 上传文件*/headers = { 'x-gmkerl-thumb': '/fw/300' }with open('文件地址', 'rb') as f: res = up.put('存到仓库的位置和文件名', f, checksum=True, headers=headers)","link":"/zhengboke/2021/03/19/python%E5%90%91%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"title":"redis发布者订阅者","text":"Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 实例以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。 在我们实例中我们创建了订阅频道名为 runoobChat: 第一个客户端 123456redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1 现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。 第二个客户端 123456789101112131415redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;(integer) 1# 订阅者的客户端会显示如下消息 1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Redis PUBLISH test&quot; 1) &quot;message&quot;2) &quot;runoobChat&quot;3) &quot;Learn redis by runoob.com&quot; 下面还有redis发布订阅的指令 1 PSUBSCRIBE pattern [pattern …] 订阅一个或多个符合给定模式的频道。 2 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 3 PUBLISH channel message 将信息发送到指定的频道。 4 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 5 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。 6 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。","link":"/zhengboke/2021/03/19/redis%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/"},{"title":"Vue路由钩子","text":"现在有一个场景，当你登录后，你的用户名需要在页面上展示，但是由于你在请求登录成功后没有将用户名存到session中，这样在跳转过去后，会读取到空白，所以这时候就可以使用路由钩子。路由钩子主要作用是拦截导航，可以在跳转前执行一些代码或进行一些判断，来决定完成跳转或者取消跳转。 首先看一下路由钩子的格式 1234567beforeRouteLeave(to,from,next){ if(sessionstorage.getItem('username'){ next(); }else{ next(false); };}; 大概就是这么个格式，参数 to ——是要跳转到的界面，from —— 从哪个界面离开，next() —— 是否允许跳转，如果是 next(false) ——禁止跳转，next({name:login}) —— 跳转到登录界面（需要自己手动配置路由），next()或者 next(true) ——允许跳转。 路由钩子有三种实现方式全局钩子 beforeEach(进入之前触发)、afterEach（进入之后触发） 123456Router.beforeEach((to,from,next)=&gt;{ ......})Router.afterEach((to,from,next)=&gt;{ ......}) 全局钩子会在每次跳转时都会被执行 路由独享钩子 beforeEnter beforeLeave 12345678910routes: [ { path: '/index', name: 'index', component: index, beforeEnter:(to, from, next) =&gt;{ next(); } } ] 路由独享，就是在路由配置中添加即可，只对被配置路由有用 组件内钩子 beforeRouteLeave beforeRouteEnter beforeRouteUpdate 12345methods:{ beforeRouteLeave(to,from,next){ ....... } } 组件内钩子写在methods中即可，从本组件进行的跳转都会触发","link":"/zhengboke/2021/03/19/vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"},{"title":"redis键空间事件","text":"功能概述键空间通知允许客户端订阅发布/订阅频道，以便以某种方式接收影响Redis数据集的事件。可能接收的事件示例如下： 所有影响给定键的命令。所有接收LPUSH操作的键。所有在数据库0中到期的键。事件使用Redis的普通发布/订阅层传递，因此实现了发布/订阅的客户端无需修改即可使用此功能。由于Redis的发布/订阅是fire and forget，因此如果你的应用要求可靠的事件通知，目前还不能使用这个功能，也就是说，如果你的发布/订阅客户端断开连接，并在稍后重连，那么所有在客户端断开期间发送的事件将会丢失。将来有计划允许更可靠的事件传递，但可能会在更一般的层面上解决，要么为发布/订阅本身带来可靠性，要么允许Lua脚本拦截发布/订阅的消息以执行推送等操作，就像往队列里推送事件一样。 事件类型键空间通知的实现是为每一个影响Redis数据空间的操作发送两个不同类型的事件。例如，在数据库0中名为mykey的键上执行DEL操作，将触发两条消息的传递，完全等同于下面两个PUBLISH命令： 12PUBLISH __keyspace@0__:mykey delPUBLISH __keyevent@0__:del mykey 以上很容易看到，一个频道允许监听所有以键mykey为目标的所有事件，以及另一个频道允许获取有关所有DEL操作目标键的信息。第一种事件，在频道中使用keyspace前缀的被叫做键空间通知，第二种，使用keyevent前缀的，被叫做键事件通知。在以上例子中，为键mykey生成了一个del事件。 会发生什么： 键空间频道接收到的消息是事件的名称。键事件频道接收到的消息是键的名称。可以只启用其中一种通知，以便只传递我们感兴趣的事件子集。 配置默认情况下，键空间事件通知是不启用的，因为虽然不太明智，但该功能会消耗一些CPU。可以使用redis.conf中的notify-keyspace-events或者使用CONFIG SET命令来开启通知。将参数设置为空字符串会禁用通知。 为了开启通知功能，使用了一个非空字符串，由多个字符组成，每一个字符都有其特殊的含义，具体参见下表： 1234567891011K 键空间事件，以__keyspace@&lt;db&gt;__前缀发布。E 键事件事件，以__keyevent@&lt;db&gt;__前缀发布。g 通用命令（非类型特定），如DEL，EXPIRE，RENAME等等$ 字符串命令l 列表命令s 集合命令h 哈希命令z 有序集合命令x 过期事件（每次键到期时生成的事件）e 被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）A g$lshzxe的别名，因此字符串AKE表示所有的事件。 字符串中应当至少存在K或者E，否则将不会传递事件，不管字符串中其余部分是什么。例如，要为列表开启键空间事件，则配置参数必须设置为Kl，以此类推。字符串KEA可以用于开启所有可能的事件。 不同的命令生成的事件根据以下列表，不同的命令产生不同种类的事件。 DEL命令为每一个删除的key生成一个del事件。RENAME生成两个事件，一个是为源key生成的rename_from事件，一个是为目标key生成的rename_to事件。EXPIRE在给一个键设置有效期时，会生成一个expire事件，或者每当设置有效期导致键被删除时，生成expired事件（请查阅EXPIRE文档以获取更多信息）。SORT会在使用STORE选项将结果存储到新键时，生成一个sortstore事件。如果结果列表为空，且使用了STORE选项，并且已经存在具有该名称的键时，那个键将被删除，因此在这种场景下会生成一个del事件。SET以及所有其变种（SETEX，SETNX，GETSET）生成set事件。但是SETEX还会生成一个expire事件。MSET为每一个key生成一个set事件。SETRANGE生成一个setrange事件。INCR、DECR、INCRBY、DECRBY命令都生成incrby事件。INCRBYFLOAT生成一个incrbyfloat事件。APPEND生成一个append事件。LPUSH和LPUSHX生成一个lpush事件，即使在可变参数情况下也是如此。RPUSH和RPUSHX生成一个rpush事件，即使在可变参数情况下也是如此。RPOP生成rpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。LPOP生成lpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。LINSERT生成一个linsert事件。LSET生成一个lset事件。LTRIM生成ltrim事件，此外，如果结果列表为空或者键被移除，将会生成一个del事件。RPOPLPUSH和BRPOPLPUSH生成rpop事件和lpush事件。这两种情况下，顺序都将得到保证（lpush事件将总是在rpop事件之后传递）。此外，如果结果列表长度为零且键被删除，则会生成一个del事件。HSET、HSETNX以及HMSET都生成一个hset事件。HINCRBY生成一个hincrby事件。HINCRBYFLOAT生成一个hincrbyfloat事件。HDEL生成一个hdel事件，此外，如果结果哈希集为空或者键被移除，将生成一个del事件。SADD生成一个sadd事件，即使在可变参数情况下也是如此。SREM生成一个srem事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。SMOVE为每一个源key生成一个srem事件，以及为每一个目标key生成一个sadd事件。SPOP生成一个spop事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。SINTERSTORE、SUNIONSTORE、SDIFFSTORE分别生成sinterstore、sunionostore、sdiffstore事件。在特殊情况下，结果集是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。ZINCR生成一个zincr事件。ZADD生成一个zadd事件，即使添加了多个元素。ZREM生成一个zrem事件，即使删除了多个元素。当结果有序集合为空且生成了键，则会生成额外的del事件。ZREMBYSCORE生成一个zrembyscore事件。当结果有序集合为空且生成了键，则会生成额外的del事件。ZREMBYRANK生成一个zrembyrank事件。当结果有序集合为空且生成了键，则会生成额外的del事件。ZINTERSTORE和ZUNIONSTORE分别生成zinterstore和zunionstore事件。在特殊情况下，结果有序集合是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。每次一个拥有过期时间的键由于过期而从数据集中移除时，将生成一个expired事件。每次一个键由于maxmemory策略而被从数据集中驱逐，以便释放内存时，将生成一个evicted事件。重要 所有命令仅在真正修改目标键时才生成事件。例如，使用SREM命令从集合中删除一个不存在的元素将不会改变键的值，因此不会生成任何事件。如果对某个命令如何生成事件有疑问，最简单的方法是自己观察：’ 1234$ redis-cli config set notify-keyspace-events KEA$ redis-cli --csv psubscribe '__key*__:*'Reading messages... (press Ctrl-C to quit)&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1 此时，在另外一个终端使用redis-cli发送命令到Redis服务器，并观察生成的事件： 123&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyspace@0__:foo&quot;,&quot;set&quot;&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyevent@0__:set&quot;,&quot;foo&quot;...","link":"/zhengboke/2021/03/19/redis%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/"},{"title":"vue父子组件的传值","text":"父组件向子组件传值 传值 &lt;header :title=&quot;hh&quot;&gt;&lt;/header&gt; 收值 123export default { props: ['title']} 以上就是单向数据流的一般表现了： 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。 子组件向父组件传参父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值。 123456789101112131415161718192021222324&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=&quot;test&quot;&gt; &lt;test-com @childFn=&quot;parentFn&quot;&gt;&lt;/test-com&gt; &lt;br/&gt; 子组件传来的值 : {{message}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { // ... data() { return { message: '' } }, methods: { parentFn(payload) { this.message = payload; } }}&lt;/script&gt; 子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。 1234567891011121314151617181920212223&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=&quot;testCom&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; &lt;button @click=&quot;click&quot;&gt;Send&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { // ... data() { return { // 默认 message: '我是来自子组件的消息' } }, methods: { click() { this.$emit('childFn', this.message); } } }&lt;/script&gt;","link":"/zhengboke/2021/03/19/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/"},{"title":"线程和线程池","text":"","link":"/zhengboke/2021/03/19/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"title":"vue拦截器的使用","text":"现在的web开发大部分是采用前后端不分离的方式，在前后端不分离的模式下前后端的交互一般是采用axios请求方式来实现。 什么是axios？axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest从 node.js 发出 http 请求支持 Promise API拦截请求和响应转换请求和响应数据取消请求自动转换JSON数据客户端支持防止 CSRF/XSR vue拦截器现在有一个场景，每次请求都要发送token来验证是否登录，但是在每个请求接口都要携带token无疑是十分麻烦，那么有没有一种方式可以让每个请求在发送前都执行某些操作呢？使用vue拦截器就是可以实现 vue拦截器的实现下载axios包 npm install axios --save 在config 中，加入 axios.js 12345678910111213141516171819202122232425# 导入axiosimport axios from 'axios' // 添加请求拦截器axios.interceptors.request.use(function (config) { // 在发送请求前会执行以下代码，这里是判断localStorage中是否存有tokenif (window.localStorage.getItem('token')) { //若token存在则在头部中携带token config.headers.Authorization = window.localStorage.getItem('token');}// 返回请求return config}, function (error) { // 当请求错误时会执行下面的代码，这里是返回错误的信息return Promise.reject(error)}); // 添加响应拦截器，响应拦截器会对相应进行处理axios.interceptors.response.use(function (response) { // 在收到响应后会执行下面的代码，这里是返回响应的信息 return response}, function (error) { // 当响应错误后会执行下面的代码，这里是返回错误信息 return Promise.reject(error)});","link":"/zhengboke/2021/03/19/vue%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"title":"微博三方登录","text":"微博三方登录流程 1.微博三方登录流程 1.1 前端获取认证code 1.在Vue页面加载时 动态发送请求获取微博授权url 2.django收到请求的url后，通过微博 应用ID(client_id)和回调地址(redirect_uri) 动态 生成授 权url返回给Vue 3.当用户点击上面的url进行扫码，授权成功会 跳转我们的回调界面并附加code参数 4.Vue获取到微博返回的code后，会 将code发送给django后端 (上面的redirect_uri) 1.2 获取微博access_token 后端获取code后，结合client_id、client_secret、redirect_uri参数进行传递,获取微博 access_token 1.3 获取微博用户基本信息并保存到数据库 使用获得的access_token调用获取用户基本信息的接口， 获取用户第三方平台的基本信息 用户基本信息 保存到数据库，然后关联本地用户 ，然后将用户信息返回给前端 1.4 生成token给Vue django后端借助微博认证成功后，可以 使用JWT生成token ，返回给Vue Vue将token存储到localStorage中 ，以便用户访问其他页面进行身份验证","link":"/zhengboke/2021/03/19/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"},{"title":"webshell","text":"Vue部分在vue中导入插件 123456import * as attach from 'xterm/lib/addons/attach/attach' // 安装插件适，可以使用attach去添加import * as fit from 'xterm/lib/addons/fit/fit' // fit进行自适应大小的import { Terminal } from 'xterm'Terminal.applyAddon(attach) // 添加插件Terminal.applyAddon(fit) // 添加插件 创建黑窗口组件 123&lt;div id=&quot;terminal&quot;&gt; &lt;!-- 黑窗口--&gt;&lt;/div&gt; 在钩子函数中初始化黑窗口对象 123456789101112131415161718192021mounted() { // 获取到了div标签 let terminalContainer = document.getElementById('terminal') // 初始化黑窗口对象 this.term = new Terminal(this.terminal) // 打开这个对象 this.term.open(terminalContainer) new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket.onopen = function(){ // 连接成功触发该方法 console.log('websocket is Connected...') } this.terminalSocket.onclose = function(){ // 连接关闭适触发的方法 console.log('websocket is Closed...') } this.terminalSocket.onerror = function(){ // 连接出错触发的方法 console.log('damn Websocket is broken!') } this.term.attach(this.terminalSocket) } Django部分导包 1234from dwebsocket import accept_websocketimport timeimport paramikofrom threading import Thread 定义连接函数 12345678910111213141516def make_ssh(host=&quot;127.0.0.1&quot;, username=&quot;root&quot;, password=&quot;123456&quot;): &quot;&quot;&quot; :host 主机地址 :username 用户名，一般是root :password 密码 :port ssh协议的端口,22 &quot;&quot;&quot; # 初始化一个ssh对象 sh = paramiko.SSHClient() # 设置对象连接密钥规则 sh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 连接 sh.connect(host, username=username, password=password, port=22) # 生成shell对象 channle = sh.invoke_shell(term='xterm') return channle 定义接收线程函数 12345678910111213def recv_ssh_msg(channle, ws): ''' 只管接收 ''' # 判断shell连接对象是否没有退出 while not channle.exit_status_ready(): # 接收过程可能会因为没有任何返回而报错 try: buf = channle.recv(1024) # 接收命令的执行结果 ws.send(buf) # 向Websocket通道返回 # 接收不到会报错，但是报错没关系，继续重新尝试接受 except: break 定义连接视图函数 1234567891011121314151617181920@accept_websocketdef webssh(request): if request.is_websocket: # 1. 获取到连接对象 ws = request.websocket # 2. 初始化linux连接 channel = make_ssh() # 3. 初始化linux数据接收线程，并开启 recv_thread = Thread(target=recv_ssh_msg, args=(channel, ws)) recv_thread.start() while 1: # 主线程: 只管发送 # 2. 阻塞ws接收发来的数据 cmd = ws.wait() # cmd = ws.recv() if cmd: channel.send(cmd) # 发送到linux 去执行 else: # 如果连接断开，那么cmd将会发一个空包 break recv_thread.join() # 回收子线程 ws.close() # 关闭ws连接","link":"/zhengboke/2021/03/19/webshell/"},{"title":"支付宝三方支付","text":"一.准备工作 123451. 登录第三方支付宝开放平台 点击链接支付宝开放平台 (https://open.alipay.com/index.htm) 2. 开发前一定要阅读支付宝官方文档中心开发步骤 3. 下载相应的开发工具包（在文档中心&gt;资源下载） 压缩包下的“支付宝钱包支付接口开发包”中即有Andoid使用支付宝的JAR和Demo 二.开发步骤创建支付宝应用（管理中心&gt;我的应用）备注：申请通过后会获得：合作者身份ID（PID），该ID在项目配置中需要用到 完善信息（上传应用图标、说明文档）配置应用环境根据API文档详解进行配置（引用自API文档）第一步 生成RSA密钥特别注意事项（坑点）下载支付宝的官网之后生成你所需要的密钥及PKCS8转码一定要小心 1234567891011121314151617生成方式一（推荐）：使用支付宝提供的一键生成工具（内附使用说明）Windows：下载 （在API文档中点击下载） MAC OSX：下载 解压打开文件夹，直接运行“支付宝RAS密钥生成器 SHAwithRSA1024_V1.0.bat”（WINDOWS） 或“SHAwithRSA1024_V1.0.command”（MACOSX），点 击“生成RSA密钥”，会自动生成公私钥，然后点击“打开文件位 置”，即可找到工具自动生成的密钥。注意：工具不支持含中文或空格的路径，请下载到英文目录下使用。生成方式二：也可以使用OpenSSL工具命令生成（详细参考API）开发者登录开放平台后，找到并进入应用。点击“RSA(SHA1)密钥”处的“设置开发者公钥”（如已设置则显示“查看开发者公钥”，可修改），将公钥文件去除头尾、换行和空格，仅需填入字符串。 例如转换前公钥pem文件格式： 12-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM/CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY/QpkddCVXnZ4bAUaQjXQIDAQAB-----END PUBLIC KEY----- 转换后得到的字符串为： 1MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM/CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY/QpkddCVXnZ4bAUaQjXQIDAQAB 第三步 获取支付宝公钥 1应用上线后点击“查看支付宝公钥”，即可获取支付宝公钥，用于支付宝返回数据的验签。 对于支付宝公钥，看到的是一个字符串，如下： 1MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB 如果需要使用文件方式（如使用服务端SDK的PHP/.NET版本）读取支付宝公钥，需要在头尾加入标示后保存至文件，文件内容如下： 123-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB-----END PUBLIC KEY----- django代码实现 读取公钥私钥 12345#生成的是app_private(私钥)app_private_key_string = open(&quot;alipay/app_private.txt&quot;).read()#生成的是alipay_public(公钥)这个公钥就支付宝的公钥把生成的公钥去沙箱复制到沙箱里面 生成一个支付宝公钥alipay_public_key_string = open(&quot;alipay/alipay_public.txt&quot;).read() 在settings.py中配置支付宝接口 1234567891011#请求支付宝接口alipay = AliPay( appid=&quot;2021000116661399&quot;, app_notify_url=None, # 默认回调url app_private_key_string=app_private_key_string, # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥, alipay_public_key_string=alipay_public_key_string, sign_type=&quot;RSA2&quot;, # RSA 或者 RSA2 debug=True, # 默认False config=AliPayConfig(timeout=15) # 可选, 请求超时时间 ) 请求视图 12345678910# 电脑网站支付，需要跳转到https://openapi.alipay.com/gateway.do? + order_string order_string = alipay.api_alipay_trade_page_pay( out_trade_no=sn, total_amount=total, subject=subject, return_url=&quot;http://www.fan.com:8080/%23/test&quot;, # notify_url=&quot;https://example.com/notify&quot; # 可选, 不填则使用默认notify url ) url = &quot;https://openapi.alipay.com/gateway.do?&quot; + order_string return Response({&quot;url&quot;: url})","link":"/zhengboke/2021/03/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"},{"title":"无极限自关联查询","text":"views.py 123456789101112131415161718192021222324252627# 无限自关联递归函数def function(id): # 接收id 查询结果集 query = User.objects.filter(uid=id) # 进行序列化 data = UserSer(query, many=True).data # 在序列化结果中添加下一级空列表列表， data['list'] = [] # 遍历结果集，递归调用并将调用结果存入上级列表 for i in data: data['list'].append(functions(i.uid)) # 返回结果集 return dataclass Path(APIView): def get(self, request): # 定义结果集列表 path_list = [] # 查取所有信息 query = Path.objects.all() # 遍历开始递归查询 for i in data: path_list.append(function(i.id)) retrun Response(path_list) models.py 123class Path(models.Model): name = models.CharField(max_leng=50) uid = models.ForeignKey(to='self', on_delete=models.SETNULL, default=None) serializers.py 1234class PathSer(ModelSerializer): class Meta: model = Path fields = '__all__'","link":"/zhengboke/2021/03/19/%E6%97%A0%E6%9E%81%E9%99%90%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"},{"title":"进程线程协程","text":"一、进程进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。 管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存（Shared Memory）；套接字（Socket）。二、线程线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。 三、进程和线程的区别与联系【区别】： 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位； 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行； 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等； 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程； 资源分配给进程，同一进程的所有线程共享该进程的所有资源； 处理机分给线程，即真正在处理机上运行的是线程； 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 四、一个形象的例子解释进程和线程的区别 这副图是一个双向多车道的道路图，假如我们把整条道路看成是一个“进程”的话，那么图中由白色虚线分隔开来的各个车道就是进程中的各个“线程”了。 这些线程(车道)共享了进程(道路)的公共资源(土地资源)。 这些线程(车道)必须依赖于进程(道路)，也就是说，线程不能脱离于进程而存在(就像离开了道路，车道也就没有意义了)。 这些线程(车道)之间可以并发执行(各个车道你走你的，我走我的)，也可以互相同步(某些车道在交通灯亮时禁止继续前行或转弯，必须等待其它车道的车辆通行完毕)。 这些线程(车道)之间依靠代码逻辑(交通灯)来控制运行，一旦代码逻辑控制有误(死锁，多个线程同时竞争唯一资源)，那么线程将陷入混乱，无序之中。 这些线程(车道)之间谁先运行是未知的，只有在线程刚好被分配到CPU时间片(交通灯变化)的那一刻才能知道。 五、进程/线程之间的亲缘性亲缘性的意思是进程/线程只在某个cpu上运行（多核系统），比如： BOOL WINAPI SetProcessAffinityMask( In HANDLE hProcess, In DWORD_PTR dwProcessAffinityMask); dwProcessAffinityMask 如果是 0 , 代表当前进程只在cpu0 上工作;如果是 0x03 , 转为2进制是 00000011 . 代表只在 cpu0 或 cpu1上工作; 使用CPU亲缘性的好处：设置CPU亲缘性是为了防止进程/线程在CPU的核上频繁切换，从而避免因切换带来的CPU的L1/L2 cache失效，cache失效会降低程序的性能。 六、协程 协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。 协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。 def A(): print ‘1’ print ‘2’ print ‘3’ def B(): print ‘x’ print ‘y’ print ‘z’ 假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：1 2 x y 3 z。 协程的特点在于是一个线程执行，那和多线程比，协程有何优势？ 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显； 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。————————————————版权声明：本文为CSDN博主「lx青萍之末」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/daaikuaichuan/article/details/82951084","link":"/zhengboke/2021/03/22/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"},{"title":"网页视频直播","text":"首先，安装OBS地址： https://obsproject.com/ 在云主机中安装NGINX 安装nginx 12yum install https://extras.getpagespeed.com/release-el$(rpm -E %{rhel})-latest.rpmyum install nginx-module-flv 1234mkdir /usr/local/nginx-flv# 创建了一个安装目录mkdir /home/flv-tools# 存储所需软件 解压 12tar -zxvf 文件名unzip 文件名 进入解压好的nginx下目录，并进行安装前的配置 1234cd nginx-1.18.0./configure --prefix=/usr/local/nginx-flv --add-module=/home/flv-tools/nginx-http-flv-module-master# --prefix: 配置安装路径#--add-module: 添加安装插件 编译及安装 make &amp;&amp; make install 打开配置文件 vim nginx.conf 配置文件修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647worker_processes 1;rtmp_auto_push on;rtmp_auto_push_reconnect 1s;rtmp_socket_dir /tmp;rtmp{ out_queue 4096; out_cork 8; max_streams 128; timeout 15s; drop_idle_publisher 15s; log_interval 5s; log_size 1m; server { listen 1935; # 推流端口 server_name zege; application live { # 配置推流地址 live on; # 打开推流 # gop_cache on; # rtmp://123.123.123.123:1935/live/test } }}events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 8080; # 拉流通过8080去拉流 # http://123.123.123.123:8080/live/?port=1935&amp;stream=test server_name localhost; location /live { flv_live on; chunked_transfer_encoding on; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; } }} 关闭旧有服务 12/usr/local/nginx-rtmp/sbin/nginx -s stop/usr/local/nginx-rtmp/sbin/nginx -s reload 开启新服务 1/usr/local/nginx-flv/sbin/nginx -c /usr/local/nginx-flv/conf/nginx.conf ! 记得在云主机管理中开放1935和8080端口 推流地址 rtmp://云主机地址:1935/live/test 拉流地址 http://云主机地址:8080/live?port=1935&amp;app=live&amp;stream=test Vue实现拉流安装 flv.js开源工具，进行拉流，哔哩哔哩开源的拉流js cnpm install flv.js --save 导包 import flv from 'flv.js'; 定义组件 123&lt;video id=&quot;videoElement&quot; controls muted&gt; Your browser is too old which doesn't support HTML5 video.&lt;/video&gt; 在钩子函数中进行初始化 12345678910111213141516171819mounted() { var videoElement = document.getElementById('videoElement'); var flvPlayer = flv.createPlayer({ type: 'flv', enableWorker: true, //浏览器端开启flv.js的worker,多进程运行flv.js isLive: true, //直播模式 hasAudio: false, //关闭音频 hasVideo: true, // cors: true, stashInitialSize: 128, enableStashBuffer: false, //播放flv时，设置是否启用播放缓存，只在直播起作用。 // url: 'http://192.168.2.234/flv/323223618780001' // url: 'http://39.105.79.238:8080/live?port=1935&amp;app=live&amp;stream=test' url: 'http://47.93.48.154:8080/live?port=1935&amp;app=live&amp;stream=test' }) flvPlayer.attachMediaElement(videoElement); flvPlayer.load(); flvPlayer.play();} 臭不要脸高磊","link":"/zhengboke/2021/03/19/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"}],"tags":[],"categories":[]}