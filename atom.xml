<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只猫头鹰</title>
  
  
  <link href="https://github.com/wisdomowl704/owlboke/atom.xml" rel="self"/>
  
  <link href="https://github.com/wisdomowl704/owlboke/"/>
  <updated>2021-04-14T08:26:27.287Z</updated>
  <id>https://github.com/wisdomowl704/owlboke/</id>
  
  <author>
    <name>猫头鹰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>P8总结</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/29/P8%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/29/P8%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-29T01:09:47.941Z</published>
    <updated>2021-04-14T08:26:27.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5次密码错误限制登录："><a href="#5次密码错误限制登录：" class="headerlink" title="5次密码错误限制登录："></a>5次密码错误限制登录：</h1><p>限制登录我们结合redis来实现，大概思路是每次登录前，先通过拿到的账号去库中拿<br>到请求登录的账号信息，从而得到id，结合id去redis中得到此账号的登录错误计数标<br>识，达到5次之间限制登录，若不到5次再判断密码是否正确，正确登录成功，错误则将r<br>edis的计数标识加1，注意需要判断是否为第一次密码错误，就是是否能拿到错误标识，<br>若拿不到错误标识，代表此次登录为第一次错误，将标识入库redis，并设置5分钟后失效。</p><p>django代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        username = request.data.get(<span class="string">'username'</span>)</span><br><span class="line">        password = request.data.get(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">        user = User.objects.filter(username=username)</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            r = MyRedis(user.first().username, decode_responses=<span class="literal">True</span>)</span><br><span class="line">            login = r.get_login()</span><br><span class="line">            <span class="keyword">if</span> login:</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'您已被限制登录'</span>, <span class="string">'code'</span>: <span class="string">'400'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'没有此用户'</span>, <span class="string">'code'</span>: <span class="string">'400'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        user = user.filter(password=password).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'登录成功'</span>, <span class="string">'code'</span>: <span class="string">'200'</span>, <span class="string">'uid'</span>: user.id&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证是否是第一次登录</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            login = r.get()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> int(login) + <span class="number">1</span> &gt;= <span class="number">5</span>:</span><br><span class="line">                r.set_login()</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'频繁输入错误密码，账号已被冻结'</span>, <span class="string">'code'</span>: <span class="string">'400'</span>&#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.set(int(login) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r.set(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'密码错误'</span>, <span class="string">'code'</span>: <span class="string">'400'</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="加权队列实现用户修改："><a href="#加权队列实现用户修改：" class="headerlink" title="加权队列实现用户修改："></a>加权队列实现用户修改：</h1><p>视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> myqueue <span class="keyword">import</span> MyQueue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateUserName</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># 获取id</span></span><br><span class="line">        uid = request.data.get(<span class="string">'uid'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            level = User.objects.get(id=int(uid)).level</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'此用户不存在'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用户名</span></span><br><span class="line">        username = request.data.get(<span class="string">'username'</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 入队</span></span><br><span class="line">        myq = MyQueue()</span><br><span class="line">        myq.add(uid=str(uid), level=str(level), username=username)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>: <span class="string">'审核中'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        myq = MyQueue()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: myq.show()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        now = datetime.datetime.now()</span><br><span class="line">        myq = MyQueue()</span><br><span class="line">        rs = myq.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>: rs, <span class="string">'time'</span>: datetime.datetime.now() - now&#125;)</span><br></pre></td></tr></table></figure><p>myqueue.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，需要导入app的模型类</span></span><br><span class="line"><span class="keyword">from</span> user.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.r = Redis(decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.r_len = self.r.hlen(<span class="string">'eb'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.r_len == <span class="number">0</span>:</span><br><span class="line">            self.r.hset(<span class="string">'eb'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>)</span><br><span class="line">            self.r.hdel(<span class="string">'eb'</span>, <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将redis中数据序列化到python中</span></span><br><span class="line">        sb = self.__by()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, uid, level, username)</span>:</span></span><br><span class="line">        <span class="comment"># 添加</span></span><br><span class="line">        self.r.hset(<span class="string">'eb'</span>, <span class="string">'&#123;&#125;+&#123;&#125;+&#123;&#125;'</span>.format(uid, level, datetime.datetime.now()), username)</span><br><span class="line">        <span class="comment"># 添加后再次读取数据，保持和redis中数据一致</span></span><br><span class="line">        self.__by()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">changess</span><span class="params">(self, user_info)</span>:</span></span><br><span class="line">        print(<span class="string">'开始'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            User.objects.filter(id=user_info[<span class="string">'uid'</span>]).update(username=user_info[<span class="string">'username'</span>])</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.r.rpush(<span class="string">'result'</span>, user_info[<span class="string">'uid'</span>] + <span class="string">'_修改失败'</span>)</span><br><span class="line">            rs = <span class="string">'成功'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.r.rpush(<span class="string">'result'</span>, user_info[<span class="string">'uid'</span>] + <span class="string">'_修改成功_'</span> + user_info[<span class="string">'username'</span>])</span><br><span class="line">            rs = <span class="string">'失败'</span></span><br><span class="line">        print(<span class="string">'结束'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> user_info <span class="keyword">in</span> self.queue:</span><br><span class="line">            <span class="keyword">await</span> self.changess(user_info)</span><br><span class="line">            key = <span class="string">'&#123;&#125;+&#123;&#125;+&#123;&#125;'</span>.format(user_info[<span class="string">'uid'</span>], user_info[<span class="string">'level'</span>], user_info[<span class="string">'date'</span>])</span><br><span class="line">            self.r.hdel(<span class="string">'eb'</span>, key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.r_len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"队列为空"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立新的循环事件</span></span><br><span class="line">        new_loop = asyncio.new_event_loop()</span><br><span class="line">        <span class="comment"># 执行循环事件</span></span><br><span class="line">        asyncio.set_event_loop(new_loop)</span><br><span class="line">        <span class="comment"># 获取循环事件</span></span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        <span class="comment"># 执行队列</span></span><br><span class="line">        loop.run_until_complete(self.put())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'OK'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_rs</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.r.lrange(<span class="string">'result'</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 清空队列</span></span><br><span class="line">        self.r.delete(<span class="string">'eb'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__by</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lis = []</span><br><span class="line">        <span class="comment"># 获取redis队列中所有数据</span></span><br><span class="line">        self.json = self.r.hgetall(<span class="string">'eb'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(self.json) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'无待执行队列'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将获取的数据序列化成python中的数据</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.json.items():</span><br><span class="line">            li = i[<span class="number">0</span>].split(<span class="string">'+'</span>)</span><br><span class="line">            self.lis.append(</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">'uid'</span>: li[<span class="number">0</span>],</span><br><span class="line">                    <span class="string">'level'</span>: li[<span class="number">1</span>],</span><br><span class="line">                    <span class="string">'date'</span>: li[<span class="number">2</span>],</span><br><span class="line">                    <span class="string">'username'</span>: i[<span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将队列数据按照等级进行第一次排序</span></span><br><span class="line">        level = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.lis)):</span><br><span class="line">            lev = self.lis[i][<span class="string">'level'</span>]</span><br><span class="line">            <span class="keyword">while</span> len(level) &lt; int(lev):</span><br><span class="line">                level.append([])</span><br><span class="line"></span><br><span class="line">            level[int(lev) - <span class="number">1</span>].append(self.lis[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个等级的数据按照创建时间排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(level)):</span><br><span class="line">            sorted(level[i], key=<span class="keyword">lambda</span> i: i[<span class="string">'date'</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        self.queue = []</span><br><span class="line">        <span class="comment"># 1级最小，逆置等级排序数组</span></span><br><span class="line">        level = level[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将各个等级合并</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> level:</span><br><span class="line">            self.queue.extend(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.queue:</span><br><span class="line">            print(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue</span><br></pre></td></tr></table></figure><h1 id="Gitee三方登录："><a href="#Gitee三方登录：" class="headerlink" title="Gitee三方登录："></a>Gitee三方登录：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Git_Client_ID = <span class="string">'用户页Client_ID'</span></span><br><span class="line"></span><br><span class="line">Git_Client_Secret = <span class="string">'用户页Client_Secret'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sf_Git_View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        code = request.GET.get(<span class="string">'code'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拼接回调地址</span></span><br><span class="line">        url = <span class="string">'https://gitee.com/oauth/token?grant_type=authorization_code'</span> \</span><br><span class="line">              <span class="string">'&amp;code=&#123;&#125;'</span> \</span><br><span class="line">              <span class="string">'&amp;client_id=&#123;&#125;'</span> \</span><br><span class="line">              <span class="string">'&amp;redirect_uri=&#123;&#125;'</span> \</span><br><span class="line">              <span class="string">'&amp;client_secret=&#123;&#125;'</span>.format(code, Git_Client_ID, redirect_uri, Git_Client_Secret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 请求token</span></span><br><span class="line">        res = requests.post(url)</span><br><span class="line">        res = json.loads(res.text)</span><br><span class="line">        <span class="comment"># 获取access_token</span></span><br><span class="line">        token = res[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">        message = requests.get(<span class="string">'https://gitee.com/api/v5/user?access_token='</span> + token)</span><br><span class="line">        mess = json.loads(message.text)</span><br><span class="line">        print(mess)</span><br><span class="line"></span><br><span class="line">        user = User.objects.filter(sf_type=<span class="string">'0b001'</span>, sf_uid=mess[<span class="string">'id'</span>]).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            user.username = mess[<span class="string">'name'</span>]</span><br><span class="line">            user.save()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            User.objects.create(username=mess[<span class="string">'name'</span>], sf_type=<span class="string">'0b001'</span>, sf_uid=mess[<span class="string">'id'</span>], password=mess[<span class="string">'name'</span>],</span><br><span class="line">                                sf=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># return Response(&#123;'username': mess['name'], 'avatar_url': mess['avatar_url']&#125;)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'http://127.0.0.1:8080/?username=&#123;&#125;'</span>.format(mess[<span class="string">'name'</span>]))</span><br></pre></td></tr></table></figure><h1 id="钉钉三方登录："><a href="#钉钉三方登录：" class="headerlink" title="钉钉三方登录："></a>钉钉三方登录：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Ding_Appid = <span class="string">'钉钉appid'</span></span><br><span class="line"></span><br><span class="line">Ding_AppSecret = <span class="string">'钉钉AppSecret'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sf_DD_View</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        code = request.GET.get(<span class="string">'code'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拼接回调地址</span></span><br><span class="line">        token_url = <span class="string">'https://oapi.dingtalk.com/sns/gettoken?appid=&#123;&#125;'</span> \</span><br><span class="line">                    <span class="string">'&amp;appsecret=&#123;&#125;'</span>.format(Ding_Appid, Ding_AppSecret)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 请求token</span></span><br><span class="line">        res = requests.get(token_url)</span><br><span class="line">        res = json.loads(res.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取access_token</span></span><br><span class="line">        token = res[<span class="string">'access_token'</span>]</span><br><span class="line">        <span class="comment"># 拼接地址</span></span><br><span class="line">        code_url = <span class="string">'https://oapi.dingtalk.com/sns/get_persistent_code?access_token=&#123;&#125;'</span>.format(token)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接口要的数据是json类型，必须转换为json类型</span></span><br><span class="line">        data = json.dumps(&#123;<span class="string">"tmp_auth_code"</span>: code&#125;, indent=<span class="number">4</span>)</span><br><span class="line">        <span class="comment"># 请求永久授权code</span></span><br><span class="line">        message = requests.post(code_url, data=data)</span><br><span class="line">        mess = json.loads(message.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到openid 和 永久授权code，后面拿用户token</span></span><br><span class="line">        openid = mess[<span class="string">'openid'</span>]</span><br><span class="line">        persistent_code = mess[<span class="string">'persistent_code'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通上个接口一样，需要json类型数据</span></span><br><span class="line">        sns_token_data = json.dumps(&#123;<span class="string">"openid"</span>: openid,</span><br><span class="line">                                     <span class="string">"persistent_code"</span>: persistent_code&#125;)</span><br><span class="line"></span><br><span class="line">        sns_token = requests.post(<span class="string">'https://oapi.dingtalk.com/sns/get_sns_token?access_token='</span> + token,</span><br><span class="line">                                  data=sns_token_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 拿到 sns_token</span></span><br><span class="line">        sns_token = json.loads(sns_token.text)[<span class="string">'sns_token'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用sns_token去请求用户信息</span></span><br><span class="line">        user_info = requests.get(<span class="string">'https://oapi.dingtalk.com/sns/getuserinfo?sns_token='</span> + sns_token)</span><br><span class="line">        user_info = json.loads(user_info.text)[<span class="string">'user_info'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否第一次登陆并录入或更新信息</span></span><br><span class="line">        user = User.objects.filter(sf_type=<span class="string">'0b010'</span>, username=user_info[<span class="string">'nick'</span>]).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            user.username = user_info[<span class="string">'nick'</span>]</span><br><span class="line">            user.save()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            User.objects.create(username=user_info[<span class="string">'nick'</span>], sf_type=<span class="string">'0b010'</span>, password=user_info[<span class="string">'nick'</span>],</span><br><span class="line">                                sf=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 前端自动跳转到首页，并携带username</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'http://127.0.0.1:8080/?username=&#123;&#125;'</span>.format(user_info[<span class="string">'nick'</span>]))</span><br></pre></td></tr></table></figure><h1 id="无极限递归查询："><a href="#无极限递归查询：" class="headerlink" title="无极限递归查询："></a>无极限递归查询：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ca</span><span class="params">(pid)</span>:</span></span><br><span class="line">    query = GongDan.objects.filter(pid=pid)</span><br><span class="line">    data = GongDanSer(query, many=<span class="literal">True</span>).data</span><br><span class="line">    lis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        i[<span class="string">'next'</span>] = ca(i[<span class="string">'id'</span>])</span><br><span class="line">    lis.append(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lis</span><br></pre></td></tr></table></figure><h1 id="七牛云又拍云后端上传实现："><a href="#七牛云又拍云后端上传实现：" class="headerlink" title="七牛云又拍云后端上传实现："></a>七牛云又拍云后端上传实现：</h1><p><a href="七牛云又拍云后端上传">http://zhengge131.gitee.io/zhengboke/2021/03/19/python%E5%90%91%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</a></p><h1 id="基于websocket实现的聊天功能："><a href="#基于websocket实现的聊天功能：" class="headerlink" title="基于websocket实现的聊天功能："></a>基于websocket实现的聊天功能：</h1><p>由于代码太乱，所以在这里我就大概讲一下逻辑，聊天功能的核心在于，聊天信息的存取问题。首先说存，存信息一定需要有三个关键字段，发送者id，接收者id，信息内容，创建时间。其中，信息内容是主要存储的东西，而发送者，接收者这是可以保证我们是否能够拿到信息的关键，并且可以保证同一条消息只需要在数据库中存一份即可。创建时间可以保证消息是有序的。除了这四个字段外，可以根据需求添加其他字段。再说说取，在取的时候，需要知道会话的发起者和接收者，这时候就对应了发送者和接收者字段，要注意的是，在会话的接收者回复时，这时消息的发送者就是会话的接收者，接收者就成了会话的发起者。二者身法需要调换。这样可以在展示的时候分辩清楚。在展示时，将会话发起者和接收者的id分别作为发送者和接收者查询消息，这样可以拿到两人的所有消息。</p><p>再说说实现。信息的发送很简单，只需要请求接口，将发送者，接收者的id已经信息内容发送到后端即可，而信息的接收需要实时刷新数据，总不能不断的请求接口吧。所以需要引用长链接webscoket，来实现后端自动向前端发送数据。</p><p>最后再说说实现群聊，群聊其实很简单，每个群都有一个群id，群聊就是，将接受者改为了群id。这样在查询时，所有在群中的人都可以作为接受者来查询到这条信息。</p><p>后端实现webscoket：</p><p>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入websocket装饰器</span></span><br><span class="line"><span class="keyword">from</span> dwebsocket.decorators <span class="keyword">import</span> accept_websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#接收前端信息</span></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_socket</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> request.websocket:</span><br><span class="line">            c=str(message,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            print(c)</span><br><span class="line">            request.websocket.send(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主动推送消息</span></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_websocket</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>) <span class="comment">## 向前端发送时间</span></span><br><span class="line">            dit = &#123;</span><br><span class="line">                <span class="string">'time'</span>:time.strftime(<span class="string">'%Y.%m.%d %H:%M:%S'</span>,time.localtime(time.time()))</span><br><span class="line">            &#125;</span><br><span class="line">            request.websocket.send(json.dumps(dit))</span><br></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'test_socket'</span>,test_socket),</span><br><span class="line">path(<span class="string">'test_websocket'</span>,test_websocket),</span><br></pre></td></tr></table></figure><p>定义前端发送消息的页面 socket.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat Room<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"chat-message-input"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"100"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"chat-message-submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Send"</span> <span class="attr">onclick</span>=<span class="string">'sendmessage()'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">   <span class="comment">//生成socket对象</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws:"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/md_admin/test_socket"</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'WebSocket open'</span>);<span class="comment">//成功连接上Websocket</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'message: '</span> + e.data);<span class="comment">//打印服务端返回的数据</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            socket.onclose=<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="actionscript">              socket.close(); <span class="comment">//关闭TCP连接</span></span></span><br><span class="line">            &#125;;</span><br><span class="line">            if (socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            socket.onopen();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.s = socket;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">sendmessage</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.s.send(<span class="built_in">document</span>.getElementById(<span class="string">"chat-message-input"</span>).value);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>js</span><br></pre></td></tr></table></figure><p>然后再定义一个页面，测试后台的主动推送socket_push.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat Room<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="actionscript">   <span class="comment">//生成socket对象</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws:"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/md_admin/test_websocket"</span>);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            socket.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'WebSocket open'</span>);<span class="comment">//成功连接上Websocket</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            socket.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'message: '</span> + e.data);<span class="comment">//打印服务端返回的数据</span></span></span><br><span class="line">            &#125;;</span><br><span class="line"><span class="actionscript">            socket.onclose=<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="actionscript">              socket.close(); <span class="comment">//关闭TCP连接</span></span></span><br><span class="line">            &#125;;</span><br><span class="line">            if (socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            socket.onopen();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5次密码错误限制登录：&quot;&gt;&lt;a href=&quot;#5次密码错误限制登录：&quot; class=&quot;headerlink&quot; title=&quot;5次密码错误限制登录：&quot;&gt;&lt;/a&gt;5次密码错误限制登录：&lt;/h1&gt;&lt;p&gt;限制登录我们结合redis来实现，大概思路是每次登录前，先通过拿到的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/23/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/23/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-03-23T02:00:09.698Z</published>
    <updated>2021-03-23T02:00:29.633Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-Python正则表达式"><a href="#title-Python正则表达式" class="headerlink" title="title:Python正则表达式"></a>title:Python正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><p>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。</p><p>re 模块使 Python 语言拥有全部的正则表达式功能。</p><p>compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p><p>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p><p>本章主要介绍Python中常用的正则表达式处理函数。</p><h3 id="re模块主要分三个正则模式-下面会一一讲解"><a href="#re模块主要分三个正则模式-下面会一一讲解" class="headerlink" title="re模块主要分三个正则模式,下面会一一讲解"></a>re模块主要分三个正则模式,下面会一一讲解</h3><h4 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h4><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p><p>语法:</p><p><code>re.match(pattern, string, flags=0)</code></p><table><thead><tr><th>pattern</th><th>匹配的正则表达式</th></tr></thead><tbody><tr><td>string</td><td>要匹配的字符串。</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：文章底下</td></tr></tbody></table><h4 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h4><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p><p>函数语法：</p><p><code>re.search(pattern, string, flags=0)</code></p><table><thead><tr><th>pattern</th><th>匹配的正则表达式</th></tr></thead><tbody><tr><td>string</td><td>要匹配的字符串。</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：文章底下</td></tr></tbody></table><p>(注：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。)</p><h2 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h2><table><thead><tr><th>re.I</th><th>使匹配对大小写不敏感</th></tr></thead><tbody><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><h2 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h2><p>模式字符串使用特殊的语法来表示一个正则表达式：</p><p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p><p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p><p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p><p>反斜杠本身需要使用反斜杠转义。</p><p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\t’，等价于 ‘\t’)匹配相应的特殊字符。</p><p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配字符串的开头</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的末尾。</td></tr><tr><td align="left">.</td><td align="left">匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td align="left">[…]</td><td align="left">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td></tr><tr><td align="left">[^…]</td><td align="left">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td align="left">re*</td><td align="left">匹配0个或多个的表达式。</td></tr><tr><td align="left">re+</td><td align="left">匹配1个或多个的表达式。</td></tr><tr><td align="left">re?</td><td align="left">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td align="left">re{ n}</td><td align="left">精确匹配 n 个前面表达式。例如， <strong>o{2}</strong> 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">re{ n,}</td><td align="left">匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。</td></tr><tr><td align="left">re{ n, m}</td><td align="left">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td align="left">a| b</td><td align="left">匹配a或b</td></tr><tr><td align="left">(re)</td><td align="left">对正则表达式分组并记住匹配的文本</td></tr><tr><td align="left">(?imx)</td><td align="left">正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td align="left">(?-imx)</td><td align="left">正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td align="left">(?: re)</td><td align="left">类似 (…), 但是不表示一个组</td></tr><tr><td align="left">(?imx: re)</td><td align="left">在括号中使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?-imx: re)</td><td align="left">在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td align="left">(?#…)</td><td align="left">注释.</td></tr><tr><td align="left">(?= re)</td><td align="left">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td align="left">(?! re)</td><td align="left">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td></tr><tr><td align="left">(?&gt; re)</td><td align="left">匹配的独立模式，省去回溯。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母数字及下划线</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母数字及下划线</td></tr><tr><td align="left">\s</td><td align="left">匹配任意空白字符，等价于 <strong>[ \t\n\r\f]</strong>。</td></tr><tr><td align="left">\S</td><td align="left">匹配任意非空字符</td></tr><tr><td align="left">\d</td><td align="left">匹配任意数字，等价于 [0-9].</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字</td></tr><tr><td align="left">\A</td><td align="left">匹配字符串开始</td></tr><tr><td align="left">\Z</td><td align="left">匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td align="left">\z</td><td align="left">匹配字符串结束</td></tr><tr><td align="left">\G</td><td align="left">匹配最后匹配完成的位置。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\n, \t, 等.</td><td align="left">匹配一个换行符。匹配一个制表符。等</td></tr><tr><td align="left">\1…\9</td><td align="left">匹配第n个分组的内容。</td></tr><tr><td align="left">\10</td><td align="left">匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><hr><h2 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h2><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><table><thead><tr><th align="left">实例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">python</td><td align="left">匹配 “python”.</td></tr></tbody></table><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><table><thead><tr><th align="left">实例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[Pp]ython</td><td align="left">匹配 “Python” 或 “python”</td></tr><tr><td align="left">rub[ye]</td><td align="left">匹配 “ruby” 或 “rube”</td></tr><tr><td align="left">[aeiou]</td><td align="left">匹配中括号内的任意一个字母</td></tr><tr><td align="left">[0-9]</td><td align="left">匹配任何数字。类似于 [0123456789]</td></tr><tr><td align="left">[a-z]</td><td align="left">匹配任何小写字母</td></tr><tr><td align="left">[A-Z]</td><td align="left">匹配任何大写字母</td></tr><tr><td align="left">[a-zA-Z0-9]</td><td align="left">匹配任何字母及数字</td></tr><tr><td align="left">[^aeiou]</td><td align="left">除了aeiou字母以外的所有字符</td></tr><tr><td align="left">[^0-9]</td><td align="left">匹配除了数字外的字符</td></tr></tbody></table><h4 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h4><table><thead><tr><th align="left">实例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\w</td><td align="left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;title-Python正则表达式&quot;&gt;&lt;a href=&quot;#title-Python正则表达式&quot; class=&quot;headerlink&quot; title=&quot;title:Python正则表达式&quot;&gt;&lt;/a&gt;title:Python正则表达式&lt;/h2&gt;&lt;p&gt;正则表达式
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>进程线程协程</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/22/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/22/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</id>
    <published>2021-03-22T12:53:11.910Z</published>
    <updated>2021-03-22T12:58:42.998Z</updated>
    
    <content type="html"><![CDATA[<p>一、进程<br>进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p><p><img src="https://img-blog.csdn.net/20150603133335514" alt="进程间通信（IPC）"></p><p>管道(Pipe)、命名管道(FIFO)、消息队列(Message Queue) 、信号量(Semaphore) 、共享内存（Shared Memory）；套接字（Socket）。<br>二、线程<br>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</p><p>三、进程和线程的区别与联系<br>【区别】：</p><p>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】：</p><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>四、一个形象的例子解释进程和线程的区别</p><p>这副图是一个双向多车道的道路图，假如我们把整条道路看成是一个“进程”的话，那么图中由白色虚线分隔开来的各个车道就是进程中的各个“线程”了。</p><p>这些线程(车道)共享了进程(道路)的公共资源(土地资源)。</p><p>这些线程(车道)必须依赖于进程(道路)，也就是说，线程不能脱离于进程而存在(就像离开了道路，车道也就没有意义了)。</p><p>这些线程(车道)之间可以并发执行(各个车道你走你的，我走我的)，也可以互相同步(某些车道在交通灯亮时禁止继续前行或转弯，必须等待其它车道的车辆通行完毕)。</p><p>这些线程(车道)之间依靠代码逻辑(交通灯)来控制运行，一旦代码逻辑控制有误(死锁，多个线程同时竞争唯一资源)，那么线程将陷入混乱，无序之中。</p><p>这些线程(车道)之间谁先运行是未知的，只有在线程刚好被分配到CPU时间片(交通灯变化)的那一刻才能知道。</p><p>五、进程/线程之间的亲缘性<br>亲缘性的意思是进程/线程只在某个cpu上运行（多核系统），比如：</p><p>BOOL WINAPI SetProcessAffinityMask(<br>  <em>In</em> HANDLE    hProcess,<br>  <em>In</em> DWORD_PTR dwProcessAffinityMask<br>);</p><p>dwProcessAffinityMask 如果是 0 , 代表当前进程只在cpu0 上工作;<br>如果是 0x03 , 转为2进制是 00000011 . 代表只在 cpu0 或 cpu1上工作;</p><p>使用CPU亲缘性的好处：设置CPU亲缘性是为了防止进程/线程在CPU的核上频繁切换，从而避免因切换带来的CPU的L1/L2 cache失效，cache失效会降低程序的性能。</p><p>六、协程</p><p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p>def A():<br>    print ‘1’<br>    print ‘2’<br>    print ‘3’</p><p>def B():<br>    print ‘x’<br>    print ‘y’<br>    print ‘z’</p><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：1 2 x y 3 z。</p><p>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p><p>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。<br>————————————————<br>版权声明：本文为CSDN博主「lx青萍之末」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82951084</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、进程&lt;br&gt;进程，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网页视频直播</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/</id>
    <published>2021-03-19T07:16:18.912Z</published>
    <updated>2021-03-19T07:16:19.470Z</updated>
    
    <content type="html"><![CDATA[<p>首先，安装OBS地址： <a href="https://obsproject.com/" target="_blank" rel="noopener">https://obsproject.com/</a></p><p>在云主机中安装NGINX</p><p>安装nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;extras.getpagespeed.com&#x2F;release-el$(rpm -E %&#123;rhel&#125;)-latest.rpm</span><br><span class="line">yum install nginx-module-flv</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nginx-flv</span><br><span class="line"># 创建了一个安装目录</span><br><span class="line">mkdir &#x2F;home&#x2F;flv-tools</span><br><span class="line"># 存储所需软件</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf 文件名</span><br><span class="line">unzip 文件名</span><br></pre></td></tr></table></figure><p>进入解压好的nginx下目录，并进行安装前的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.18.0</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-flv --add-module&#x3D;&#x2F;home&#x2F;flv-tools&#x2F;nginx-http-flv-module-master</span><br><span class="line"># --prefix: 配置安装路径</span><br><span class="line">#--add-module: 添加安装插件</span><br></pre></td></tr></table></figure><p>编译及安装</p><p><code>make &amp;&amp; make install</code></p><p>打开配置文件</p><p><code>vim nginx.conf</code></p><p>配置文件修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">rtmp_auto_push on;</span><br><span class="line">rtmp_auto_push_reconnect 1s;</span><br><span class="line">rtmp_socket_dir &#x2F;tmp;</span><br><span class="line"></span><br><span class="line">rtmp&#123;</span><br><span class="line">out_queue 4096;</span><br><span class="line">out_cork 8;</span><br><span class="line">max_streams 128;</span><br><span class="line">timeout 15s;</span><br><span class="line">drop_idle_publisher 15s;</span><br><span class="line">log_interval 5s;</span><br><span class="line">log_size 1m;</span><br><span class="line">server &#123;</span><br><span class="line">listen 1935; # 推流端口</span><br><span class="line">server_name zege;</span><br><span class="line"></span><br><span class="line">application live &#123;# 配置推流地址</span><br><span class="line">live on; # 打开推流</span><br><span class="line"># gop_cache on;</span><br><span class="line"># rtmp:&#x2F;&#x2F;123.123.123.123:1935&#x2F;live&#x2F;test</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">include       mime.types;</span><br><span class="line">default_type  application&#x2F;octet-stream;</span><br><span class="line">sendfile        on;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line">server &#123;</span><br><span class="line">listen       8080; # 拉流通过8080去拉流</span><br><span class="line"># http:&#x2F;&#x2F;123.123.123.123:8080&#x2F;live&#x2F;?port&#x3D;1935&amp;stream&#x3D;test</span><br><span class="line">server_name  localhost;</span><br><span class="line">location &#x2F;live &#123;</span><br><span class="line">flv_live on;</span><br><span class="line">chunked_transfer_encoding  on;</span><br><span class="line">add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;</span><br><span class="line">add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭旧有服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx-rtmp&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx-rtmp&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p>开启新服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx-flv&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx-flv&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>! 记得在云主机管理中开放1935和8080端口</p><p>推流地址</p><p><code>rtmp://云主机地址:1935/live/test</code></p><p>拉流地址</p><p><code>http://云主机地址:8080/live?port=1935&amp;app=live&amp;stream=test</code></p><h3 id="Vue实现拉流"><a href="#Vue实现拉流" class="headerlink" title="Vue实现拉流"></a>Vue实现拉流</h3><p>安装 flv.js开源工具，进行拉流，哔哩哔哩开源的拉流js</p><p><code>cnpm install flv.js --save</code></p><p>导包</p><p><code>import flv from &#39;flv.js&#39;;</code></p><p>定义组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video id&#x3D;&quot;videoElement&quot; controls muted&gt;</span><br><span class="line">  Your browser is too old which doesn&#39;t support HTML5 video.</span><br><span class="line">&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure><p>在钩子函数中进行初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    var videoElement &#x3D; document.getElementById(&#39;videoElement&#39;);</span><br><span class="line">    var flvPlayer &#x3D; flv.createPlayer(&#123;</span><br><span class="line">      type: &#39;flv&#39;,</span><br><span class="line">      enableWorker: true,     &#x2F;&#x2F;浏览器端开启flv.js的worker,多进程运行flv.js</span><br><span class="line">      isLive: true,           &#x2F;&#x2F;直播模式</span><br><span class="line">      hasAudio: false,        &#x2F;&#x2F;关闭音频</span><br><span class="line">      hasVideo: true,</span><br><span class="line">      &#x2F;&#x2F; cors: true,</span><br><span class="line">      stashInitialSize: 128,</span><br><span class="line">      enableStashBuffer: false, &#x2F;&#x2F;播放flv时，设置是否启用播放缓存，只在直播起作用。</span><br><span class="line">      &#x2F;&#x2F; url: &#39;http:&#x2F;&#x2F;192.168.2.234&#x2F;flv&#x2F;323223618780001&#39;</span><br><span class="line">      &#x2F;&#x2F; url: &#39;http:&#x2F;&#x2F;39.105.79.238:8080&#x2F;live?port&#x3D;1935&amp;app&#x3D;live&amp;stream&#x3D;test&#39;</span><br><span class="line">      url: &#39;http:&#x2F;&#x2F;47.93.48.154:8080&#x2F;live?port&#x3D;1935&amp;app&#x3D;live&amp;stream&#x3D;test&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    flvPlayer.attachMediaElement(videoElement);</span><br><span class="line">    flvPlayer.load();</span><br><span class="line">    flvPlayer.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="臭不要脸高磊"><a href="#臭不要脸高磊" class="headerlink" title="臭不要脸高磊"></a>臭不要脸高磊</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，安装OBS地址： &lt;a href=&quot;https://obsproject.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://obsproject.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在云主机中安装NGINX&lt;/p&gt;
&lt;p&gt;安装ngi
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>无极限自关联查询</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/%E6%97%A0%E6%9E%81%E9%99%90%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/%E6%97%A0%E6%9E%81%E9%99%90%E8%87%AA%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-03-19T07:16:18.904Z</published>
    <updated>2021-03-19T07:16:19.465Z</updated>
    
    <content type="html"><![CDATA[<p>views.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 无限自关联递归函数</span><br><span class="line"></span><br><span class="line">def function(id):</span><br><span class="line">    # 接收id 查询结果集</span><br><span class="line">    query &#x3D; User.objects.filter(uid&#x3D;id)</span><br><span class="line">    # 进行序列化</span><br><span class="line">    data &#x3D; UserSer(query, many&#x3D;True).data</span><br><span class="line">    # 在序列化结果中添加下一级空列表列表，</span><br><span class="line">    data[&#39;list&#39;] &#x3D; []</span><br><span class="line">    # 遍历结果集，递归调用并将调用结果存入上级列表</span><br><span class="line">    for i in data:</span><br><span class="line">        data[&#39;list&#39;].append(functions(i.uid))</span><br><span class="line"></span><br><span class="line">    # 返回结果集</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">class Path(APIView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        # 定义结果集列表</span><br><span class="line">        path_list &#x3D; []</span><br><span class="line">        # 查取所有信息</span><br><span class="line">        query &#x3D; Path.objects.all()</span><br><span class="line">        # 遍历开始递归查询</span><br><span class="line">        for i in data:</span><br><span class="line">            path_list.append(function(i.id))</span><br><span class="line">        </span><br><span class="line">        retrun Response(path_list)</span><br></pre></td></tr></table></figure><p>models.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Path(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_leng&#x3D;50)</span><br><span class="line">    uid &#x3D; models.ForeignKey(to&#x3D;&#39;self&#39;, on_delete&#x3D;models.SETNULL, default&#x3D;None)</span><br></pre></td></tr></table></figure><p>serializers.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class PathSer(ModelSerializer):</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Path</span><br><span class="line">        fields &#x3D; &#39;__all__&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;views.py&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>支付宝三方支付</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/</id>
    <published>2021-03-19T07:16:18.901Z</published>
    <updated>2021-03-19T07:16:19.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../images/irMW5h7x2I8SOZT.png" alt="支付宝三方支付流程图"></p><p>一.准备工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 登录第三方支付宝开放平台 </span><br><span class="line">点击链接支付宝开放平台 (https:&#x2F;&#x2F;open.alipay.com&#x2F;index.htm) </span><br><span class="line">2. 开发前一定要阅读支付宝官方文档中心开发步骤 </span><br><span class="line">3. 下载相应的开发工具包（在文档中心&gt;资源下载） </span><br><span class="line">压缩包下的“支付宝钱包支付接口开发包”中即有Andoid使用支付宝的JAR和Demo</span><br></pre></td></tr></table></figure><p>二.开发步骤<br>创建支付宝应用（管理中心&gt;我的应用）<br>备注：申请通过后会获得：合作者身份ID（PID），该ID在项目配置中需要用到</p><p>完善信息（上传应用图标、说明文档）<br>配置应用环境<br>根据API文档详解进行配置（引用自API文档）<br>第一步 生成RSA密钥<br>特别注意事项（坑点）<br>下载支付宝的官网之后生成你所需要的密钥及PKCS8转码一定要小心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">生成方式一（推荐）：使用支付宝提供的一键生成工具（内附使用说明）</span><br><span class="line"></span><br><span class="line">Windows：下载 （在API文档中点击下载） </span><br><span class="line">MAC OSX：下载 </span><br><span class="line">解压打开文件夹，直接运行“支付宝RAS密钥生成器 </span><br><span class="line">SHAwithRSA1024_V1.0.bat”（WINDOWS） </span><br><span class="line">或“SHAwithRSA1024_V1.0.command”（MACOSX），点 </span><br><span class="line">击“生成RSA密钥”，会自动生成公私钥，然后点击“打开文件位 </span><br><span class="line">置”，即可找到工具自动生成的密钥。</span><br><span class="line"></span><br><span class="line">注意：工具不支持含中文或空格的路径，请下载到英文目录下使用。</span><br><span class="line"></span><br><span class="line">生成方式二：也可以使用OpenSSL工具命令生成（详细参考API）</span><br><span class="line"></span><br><span class="line">开发者登录开放平台后，找到并进入应用。</span><br><span class="line"></span><br><span class="line">点击“RSA(SHA1)密钥”处的“设置开发者公钥”（如已设置则显示“查看开发者公钥”，可修改），将公钥文件去除头尾、换行和空格，仅需填入字符串。</span><br></pre></td></tr></table></figure><p>例如转换前公钥pem文件格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM&#x2F;CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY&#x2F;QpkddCVXnZ4bAUaQjXQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>转换后得到的字符串为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDQWiDVZ7XYxa4CQsZoB3n7bfxLDkeGKjyQPt2FUtm4TWX9OYrd523iw6UUqnQ+Evfw88JgRnhyXadp+vnPKP7unormYQAfsM&#x2F;CxzrfMoVdtwSiGtIJB4pfyRXjA+KL8nIa2hdQy5nLfgPVGZN4WidfUY&#x2F;QpkddCVXnZ4bAUaQjXQIDAQAB</span><br></pre></td></tr></table></figure><p>第三步 获取支付宝公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用上线后点击“查看支付宝公钥”，即可获取支付宝公钥，用于支付宝返回数据的验签。</span><br></pre></td></tr></table></figure><p>对于支付宝公钥，看到的是一个字符串，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi&#x2F;fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI&#x2F;FCEa3&#x2F;cNMW0QIDAQAB</span><br></pre></td></tr></table></figure><p>如果需要使用文件方式（如使用服务端SDK的PHP/.NET版本）读取支付宝公钥，需要在头尾加入标示后保存至文件，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi&#x2F;fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI&#x2F;FCEa3&#x2F;cNMW0QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>django代码实现</p><p>读取公钥私钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#生成的是app_private(私钥)</span><br><span class="line">app_private_key_string &#x3D; open(&quot;alipay&#x2F;app_private.txt&quot;).read()</span><br><span class="line">#生成的是alipay_public(公钥)这个公钥就支付宝的公钥</span><br><span class="line">把生成的公钥去沙箱复制到沙箱里面 生成一个支付宝公钥</span><br><span class="line">alipay_public_key_string &#x3D; open(&quot;alipay&#x2F;alipay_public.txt&quot;).read()</span><br></pre></td></tr></table></figure><p>在settings.py中配置支付宝接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#请求支付宝接口</span><br><span class="line">alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;&quot;2021000116661399&quot;,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_string&#x3D;app_private_key_string,</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        alipay_public_key_string&#x3D;alipay_public_key_string,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA 或者 RSA2</span><br><span class="line">        debug&#x3D;True,  # 默认False</span><br><span class="line">        config&#x3D;AliPayConfig(timeout&#x3D;15)  # 可选, 请求超时时间</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>请求视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 电脑网站支付，需要跳转到https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do? + order_string</span><br><span class="line">        order_string &#x3D; alipay.api_alipay_trade_page_pay(</span><br><span class="line">            out_trade_no&#x3D;sn,</span><br><span class="line">            total_amount&#x3D;total,</span><br><span class="line">            subject&#x3D;subject,</span><br><span class="line">            return_url&#x3D;&quot;http:&#x2F;&#x2F;www.fan.com:8080&#x2F;%23&#x2F;test&quot;,</span><br><span class="line">            # notify_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&#x2F;notify&quot;  # 可选, 不填则使用默认notify url</span><br><span class="line">        )</span><br><span class="line">        url &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do?&quot; + order_string</span><br><span class="line">        return Response(&#123;&quot;url&quot;: url&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;../images/irMW5h7x2I8SOZT.png&quot; alt=&quot;支付宝三方支付流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;一.准备工作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>微博三方登录</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/%E5%BE%AE%E5%8D%9A%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</id>
    <published>2021-03-19T07:16:18.899Z</published>
    <updated>2021-03-22T13:13:07.910Z</updated>
    
    <content type="html"><![CDATA[<p>　微博三方登录流程</p><h3 id="1-微博三方登录流程"><a href="#1-微博三方登录流程" class="headerlink" title="1.微博三方登录流程"></a>1.微博三方登录流程</h3><p> 1.1 前端获取认证code</p><p> 　　1.在Vue页面加载时 动态发送请求获取微博授权url<br> 　　2.django收到请求的url后，通过微博 应用ID(client_id)和回调地址(redirect_uri) 动态 生成授<br> 　　权url返回给Vue<br> 　　3.当用户点击上面的url进行扫码，授权成功会 跳转我们的回调界面并附加code参数　　<br> 　　4.Vue获取到微博返回的code后，会 将code发送给django后端 (上面的redirect_uri)</p><p> 1.2 获取微博access_token</p><p> 　　后端获取code后，结合client_id、client_secret、redirect_uri参数进行传递,获取微博<br> 　　access_token</p><p> 1.3 获取微博用户基本信息并保存到数据库</p><p> 使用获得的access_token调用获取用户基本信息的接口， 获取用户第三方平台的基本信息<br> 用户基本信息 保存到数据库，然后关联本地用户 ，然后将用户信息返回给前端<br> 1.4 生成token给Vue<br> django后端借助微博认证成功后，可以 使用JWT生成token ，返回给Vue<br> Vue将token存储到localStorage中 ，以便用户访问其他页面进行身份验证</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　微博三方登录流程&lt;/p&gt;
&lt;h3 id=&quot;1-微博三方登录流程&quot;&gt;&lt;a href=&quot;#1-微博三方登录流程&quot; class=&quot;headerlink&quot; title=&quot;1.微博三方登录流程&quot;&gt;&lt;/a&gt;1.微博三方登录流程&lt;/h3&gt;&lt;p&gt; 1.1 前端获取认证code&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>webshell</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/webshell/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/webshell/</id>
    <published>2021-03-19T07:16:18.896Z</published>
    <updated>2021-03-19T07:16:19.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue部分"><a href="#Vue部分" class="headerlink" title="Vue部分"></a>Vue部分</h3><p>在vue中导入插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import * as attach from &#39;xterm&#x2F;lib&#x2F;addons&#x2F;attach&#x2F;attach&#39; &#x2F;&#x2F; 安装插件适，可以使用attach去添加</span><br><span class="line">import * as fit from &#39;xterm&#x2F;lib&#x2F;addons&#x2F;fit&#x2F;fit&#39; &#x2F;&#x2F; fit进行自适应大小的</span><br><span class="line"></span><br><span class="line">import &#123; Terminal &#125; from &#39;xterm&#39;</span><br><span class="line">Terminal.applyAddon(attach) &#x2F;&#x2F; 添加插件</span><br><span class="line">Terminal.applyAddon(fit) &#x2F;&#x2F; 添加插件</span><br></pre></td></tr></table></figure><p>创建黑窗口组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;terminal&quot;&gt;</span><br><span class="line">    &lt;!--            黑窗口--&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>在钩子函数中初始化黑窗口对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取到了div标签</span><br><span class="line">        let terminalContainer &#x3D; document.getElementById(&#39;terminal&#39;)</span><br><span class="line">        &#x2F;&#x2F; 初始化黑窗口对象</span><br><span class="line">        this.term &#x3D; new Terminal(this.terminal)</span><br><span class="line">        &#x2F;&#x2F; 打开这个对象</span><br><span class="line">        this.term.open(terminalContainer)</span><br><span class="line"></span><br><span class="line">        new WebSocket(&#39;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;webssh&#x2F;&#39;)</span><br><span class="line">        this.terminalSocket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;webssh&#x2F;&#39;)</span><br><span class="line">        this.terminalSocket.onopen &#x3D; function()&#123; &#x2F;&#x2F; 连接成功触发该方法</span><br><span class="line">            console.log(&#39;websocket is Connected...&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.terminalSocket.onclose &#x3D; function()&#123; &#x2F;&#x2F; 连接关闭适触发的方法</span><br><span class="line">            console.log(&#39;websocket is Closed...&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.terminalSocket.onerror &#x3D; function()&#123; &#x2F;&#x2F; 连接出错触发的方法</span><br><span class="line">            console.log(&#39;damn Websocket is broken!&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        this.term.attach(this.terminalSocket)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Django部分"><a href="#Django部分" class="headerlink" title="Django部分"></a>Django部分</h3><p>导包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from dwebsocket import accept_websocket</span><br><span class="line">import time</span><br><span class="line">import paramiko</span><br><span class="line">from threading import Thread</span><br></pre></td></tr></table></figure><p>定义连接函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def make_ssh(host&#x3D;&quot;127.0.0.1&quot;, username&#x3D;&quot;root&quot;, password&#x3D;&quot;123456&quot;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :host 主机地址</span><br><span class="line">    :username 用户名，一般是root</span><br><span class="line">    :password 密码</span><br><span class="line">    :port ssh协议的端口,22</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化一个ssh对象</span><br><span class="line">    sh &#x3D; paramiko.SSHClient()</span><br><span class="line">    # 设置对象连接密钥规则</span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    # 连接</span><br><span class="line">    sh.connect(host, username&#x3D;username, password&#x3D;password, port&#x3D;22)</span><br><span class="line">    # 生成shell对象</span><br><span class="line">    channle &#x3D; sh.invoke_shell(term&#x3D;&#39;xterm&#39;)</span><br><span class="line">    return channle</span><br></pre></td></tr></table></figure><p>定义接收线程函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def recv_ssh_msg(channle, ws):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">        只管接收</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    # 判断shell连接对象是否没有退出</span><br><span class="line">    while not channle.exit_status_ready():</span><br><span class="line">        # 接收过程可能会因为没有任何返回而报错</span><br><span class="line">        try:</span><br><span class="line">            buf &#x3D; channle.recv(1024)  # 接收命令的执行结果</span><br><span class="line">            ws.send(buf)  # 向Websocket通道返回</span><br><span class="line">        # 接收不到会报错，但是报错没关系，继续重新尝试接受</span><br><span class="line">        except:</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>定义连接视图函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@accept_websocket</span><br><span class="line">def webssh(request):</span><br><span class="line">    if request.is_websocket:</span><br><span class="line">        # 1. 获取到连接对象</span><br><span class="line">        ws &#x3D; request.websocket</span><br><span class="line">        # 2. 初始化linux连接</span><br><span class="line">        channel &#x3D; make_ssh()</span><br><span class="line">        # 3. 初始化linux数据接收线程，并开启</span><br><span class="line">        recv_thread &#x3D; Thread(target&#x3D;recv_ssh_msg, args&#x3D;(channel, ws))</span><br><span class="line">        recv_thread.start()</span><br><span class="line">        while 1:  # 主线程: 只管发送</span><br><span class="line">            # 2. 阻塞ws接收发来的数据</span><br><span class="line">            cmd &#x3D; ws.wait()</span><br><span class="line">            # cmd &#x3D; ws.recv()</span><br><span class="line">            if cmd:</span><br><span class="line">                channel.send(cmd)  # 发送到linux 去执行</span><br><span class="line">            else:  # 如果连接断开，那么cmd将会发一个空包</span><br><span class="line">                break</span><br><span class="line">        recv_thread.join()  # 回收子线程</span><br><span class="line">        ws.close()  # 关闭ws连接</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue部分&quot;&gt;&lt;a href=&quot;#Vue部分&quot; class=&quot;headerlink&quot; title=&quot;Vue部分&quot;&gt;&lt;/a&gt;Vue部分&lt;/h3&gt;&lt;p&gt;在vue中导入插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue路由钩子</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/</id>
    <published>2021-03-19T07:16:18.893Z</published>
    <updated>2021-03-19T07:16:19.451Z</updated>
    
    <content type="html"><![CDATA[<p>现在有一个场景，当你登录后，你的用户名需要在页面上展示，但是由于你在请求<br>登录成功后没有将用户名存到session中，这样在跳转过去后，会读取到<br>空白，所以这时候就可以使用路由钩子。路由钩子主要作用是拦截导航，可以在跳转前执行一些代码或进行一些判断，<br>来决定完成跳转或者取消跳转。</p><p>首先看一下路由钩子的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">  if(sessionstorage.getItem(&#39;username&#39;)&#123;</span><br><span class="line">      next();</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    next(false);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大概就是这么个格式，参数 to ——是要跳转到的界面，from —— 从哪个界面离开，next()<br> —— 是否允许跳转，如果是 next(false) ——禁止跳转，<br>next({name:login}) —— 跳转到登录界面（需要自己手动配置路由），next()<br>或者 next(true) ——允许跳转。</p><h3 id="路由钩子有三种实现方式"><a href="#路由钩子有三种实现方式" class="headerlink" title="路由钩子有三种实现方式"></a>路由钩子有三种实现方式</h3><p><strong>全局钩子</strong></p><p>beforeEach(进入之前触发)、afterEach（进入之后触发）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Router.beforeEach((to,from,next)&#x3D;&gt;&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;)</span><br><span class="line">Router.afterEach((to,from,next)&#x3D;&gt;&#123;</span><br><span class="line">      ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>全局钩子会在每次跳转时都会被执行</p><p><strong>路由独享钩子</strong></p><p>beforeEnter  beforeLeave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#39;&#x2F;index&#39;,</span><br><span class="line">            name: &#39;index&#39;,</span><br><span class="line">            component: index,</span><br><span class="line">            beforeEnter:(to, from, next) &#x3D;&gt;&#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>路由独享，就是在路由配置中添加即可，只对被配置路由有用</p><p><strong>组件内钩子</strong></p><p>beforeRouteLeave beforeRouteEnter beforeRouteUpdate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">      beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">            .......</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>组件内钩子写在methods中即可，从本组件进行的跳转都会触发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在有一个场景，当你登录后，你的用户名需要在页面上展示，但是由于你在请求&lt;br&gt;登录成功后没有将用户名存到session中，这样在跳转过去后，会读取到&lt;br&gt;空白，所以这时候就可以使用路由钩子。路由钩子主要作用是拦截导航，可以在跳转前执行一些代码或进行一些判断，&lt;br&gt;来决
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue父子组件的传值</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</id>
    <published>2021-03-19T07:16:18.890Z</published>
    <updated>2021-03-19T07:16:19.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><ul><li>传值</li></ul><p><code>&lt;header :title=&quot;hh&quot;&gt;&lt;/header&gt;</code></p><ul><li>收值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;title&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是单向数据流的一般表现了： 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。</p><h3 id="子组件向父组件传参"><a href="#子组件向父组件传参" class="headerlink" title="子组件向父组件传参"></a>子组件向父组件传参</h3><p>父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;test&quot;&gt;</span><br><span class="line">      &lt;test-com @childFn&#x3D;&quot;parentFn&quot;&gt;&lt;&#x2F;test-com&gt;</span><br><span class="line">      &lt;br&#x2F;&gt; </span><br><span class="line">      子组件传来的值 : &#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">             message: &#39;&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">       parentFn(payload) &#123;</span><br><span class="line">        this.message &#x3D; payload;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt; </span><br><span class="line">&lt;div class&#x3D;&quot;testCom&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;message&quot; &#x2F;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;click&quot;&gt;Send&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          &#x2F;&#x2F; 默认</span><br><span class="line">          message: &#39;我是来自子组件的消息&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      click() &#123;</span><br><span class="line">            this.$emit(&#39;childFn&#39;, this.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;父组件向子组件传值&quot;&gt;&lt;a href=&quot;#父组件向子组件传值&quot; class=&quot;headerlink&quot; title=&quot;父组件向子组件传值&quot;&gt;&lt;/a&gt;父组件向子组件传值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;传值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;header :t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue拦截器的使用</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/vue%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2021-03-19T07:16:18.887Z</published>
    <updated>2021-03-19T07:16:19.444Z</updated>
    
    <content type="html"><![CDATA[<p>现在的web开发大部分是采用前后端不分离的方式，在前后端不分离的模式下前后端的交互一般是采用axios请求方式来实现。</p><h3 id="什么是axios？"><a href="#什么是axios？" class="headerlink" title="什么是axios？"></a>什么是axios？</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><p>从浏览器中创建 XMLHttpRequest<br>从 node.js 发出 http 请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求和响应数据<br>取消请求<br>自动转换JSON数据<br>客户端支持防止 CSRF/XSR</p><h3 id="vue拦截器"><a href="#vue拦截器" class="headerlink" title="vue拦截器"></a>vue拦截器</h3><p>现在有一个场景，每次请求都要发送token来验证是否登录，但是在每个请求接口都要携带token无疑是十分麻烦，<br>那么有没有一种方式可以让每个请求在发送前都执行某些操作呢？使用vue拦截器就是可以实现</p><h3 id="vue拦截器的实现"><a href="#vue拦截器的实现" class="headerlink" title="vue拦截器的实现"></a>vue拦截器的实现</h3><p>下载axios包</p><p><code>npm install axios --save</code></p><p>在config 中，加入  axios.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 导入axios</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 添加请求拦截器</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">　　&#x2F;&#x2F; 在发送请求前会执行以下代码，这里是判断localStorage中是否存有token</span><br><span class="line">if (window.localStorage.getItem(&#39;token&#39;)) &#123;</span><br><span class="line">    &#x2F;&#x2F;若token存在则在头部中携带token</span><br><span class="line">    config.headers.Authorization &#x3D; window.localStorage.getItem(&#39;token&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 返回请求</span><br><span class="line">return config</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">　　&#x2F;&#x2F; 当请求错误时会执行下面的代码，这里是返回错误的信息</span><br><span class="line">return Promise.reject(error)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 添加响应拦截器，响应拦截器会对相应进行处理</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">　　&#x2F;&#x2F; 在收到响应后会执行下面的代码，这里是返回响应的信息</span><br><span class="line">　　return response</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">　　&#x2F;&#x2F; 当响应错误后会执行下面的代码，这里是返回错误信息</span><br><span class="line">　　return Promise.reject(error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在的web开发大部分是采用前后端不分离的方式，在前后端不分离的模式下前后端的交互一般是采用axios请求方式来实现。&lt;/p&gt;
&lt;h3 id=&quot;什么是axios？&quot;&gt;&lt;a href=&quot;#什么是axios？&quot; class=&quot;headerlink&quot; title=&quot;什么是axio
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis键空间事件</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/redis%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/redis%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/</id>
    <published>2021-03-19T07:16:18.884Z</published>
    <updated>2021-03-19T07:16:19.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h3><p>键空间通知允许客户端订阅发布/订阅频道，以便以某种方式接收影响Redis数据集的事件。可能接收的事件示例如下：</p><p>所有影响给定键的命令。<br>所有接收LPUSH操作的键。<br>所有在数据库0中到期的键。<br>事件使用Redis的普通发布/订阅层传递，因此实现了发布/订阅的客户端无需修改即可使用此功能。由于Redis的发布/订阅是fire and forget，因此如果你的应用要求可靠的事件通知，目前还不能使用这个功能，也就是说，如果你的发布/订阅客户端断开连接，并在稍后重连，那么所有在客户端断开期间发送的事件将会丢失。将来有计划允许更可靠的事件传递，但可能会在更一般的层面上解决，要么为发布/订阅本身带来可靠性，要么允许Lua脚本拦截发布/订阅的消息以执行推送等操作，就像往队列里推送事件一样。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>键空间通知的实现是为每一个影响Redis数据空间的操作发送两个不同类型的事件。例如，在数据库0中名为mykey的键上执行DEL操作，将触发两条消息的传递，完全等同于下面两个PUBLISH命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>以上很容易看到，一个频道允许监听所有以键mykey为目标的所有事件，以及另一个频道允许获取有关所有DEL操作目标键的信息。第一种事件，在频道中使用keyspace前缀的被叫做键空间通知，第二种，使用keyevent前缀的，被叫做键事件通知。在以上例子中，为键mykey生成了一个del事件。 会发生什么：</p><p>键空间频道接收到的消息是事件的名称。<br>键事件频道接收到的消息是键的名称。<br>可以只启用其中一种通知，以便只传递我们感兴趣的事件子集。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>默认情况下，键空间事件通知是不启用的，因为虽然不太明智，但该功能会消耗一些CPU。可以使用redis.conf中的notify-keyspace-events或者使用CONFIG SET命令来开启通知。将参数设置为空字符串会禁用通知。 为了开启通知功能，使用了一个非空字符串，由多个字符组成，每一个字符都有其特殊的含义，具体参见下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">K     键空间事件，以__keyspace@&lt;db&gt;__前缀发布。</span><br><span class="line">E     键事件事件，以__keyevent@&lt;db&gt;__前缀发布。</span><br><span class="line">g     通用命令（非类型特定），如DEL，EXPIRE，RENAME等等</span><br><span class="line">$     字符串命令</span><br><span class="line">l     列表命令</span><br><span class="line">s     集合命令</span><br><span class="line">h     哈希命令</span><br><span class="line">z     有序集合命令</span><br><span class="line">x     过期事件（每次键到期时生成的事件）</span><br><span class="line">e     被驱逐的事件（当一个键由于达到最大内存而被驱逐时产生的事件）</span><br><span class="line">A     g$lshzxe的别名，因此字符串AKE表示所有的事件。</span><br></pre></td></tr></table></figure><p>字符串中应当至少存在K或者E，否则将不会传递事件，不管字符串中其余部分是什么。例如，要为列表开启键空间事件，则配置参数必须设置为Kl，以此类推。字符串KEA可以用于开启所有可能的事件。</p><h3 id="不同的命令生成的事件"><a href="#不同的命令生成的事件" class="headerlink" title="不同的命令生成的事件"></a>不同的命令生成的事件</h3><p>根据以下列表，不同的命令产生不同种类的事件。</p><p>DEL命令为每一个删除的key生成一个del事件。<br>RENAME生成两个事件，一个是为源key生成的rename_from事件，一个是为目标key生成的rename_to事件。<br>EXPIRE在给一个键设置有效期时，会生成一个expire事件，或者每当设置有效期导致键被删除时，生成expired事件（请查阅EXPIRE文档以获取更多信息）。<br>SORT会在使用STORE选项将结果存储到新键时，生成一个sortstore事件。如果结果列表为空，且使用了STORE选项，并且已经存在具有该名称的键时，那个键将被删除，因此在这种场景下会生成一个del事件。<br>SET以及所有其变种（SETEX，SETNX，GETSET）生成set事件。但是SETEX还会生成一个expire事件。<br>MSET为每一个key生成一个set事件。<br>SETRANGE生成一个setrange事件。<br>INCR、DECR、INCRBY、DECRBY命令都生成incrby事件。<br>INCRBYFLOAT生成一个incrbyfloat事件。<br>APPEND生成一个append事件。<br>LPUSH和LPUSHX生成一个lpush事件，即使在可变参数情况下也是如此。<br>RPUSH和RPUSHX生成一个rpush事件，即使在可变参数情况下也是如此。<br>RPOP生成rpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。<br>LPOP生成lpop事件。此外，如果键由于列表中的最后一个元素弹出而被删除，则会生成一个del事件。<br>LINSERT生成一个linsert事件。<br>LSET生成一个lset事件。<br>LTRIM生成ltrim事件，此外，如果结果列表为空或者键被移除，将会生成一个del事件。<br>RPOPLPUSH和BRPOPLPUSH生成rpop事件和lpush事件。这两种情况下，顺序都将得到保证（lpush事件将总是在rpop事件之后传递）。此外，如果结果列表长度为零且键被删除，则会生成一个del事件。<br>HSET、HSETNX以及HMSET都生成一个hset事件。<br>HINCRBY生成一个hincrby事件。<br>HINCRBYFLOAT生成一个hincrbyfloat事件。<br>HDEL生成一个hdel事件，此外，如果结果哈希集为空或者键被移除，将生成一个del事件。<br>SADD生成一个sadd事件，即使在可变参数情况下也是如此。<br>SREM生成一个srem事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。<br>SMOVE为每一个源key生成一个srem事件，以及为每一个目标key生成一个sadd事件。<br>SPOP生成一个spop事件，此外，如果结果集合为空或者键被移除，将生成一个del事件。<br>SINTERSTORE、SUNIONSTORE、SDIFFSTORE分别生成sinterstore、sunionostore、sdiffstore事件。在特殊情况下，结果集是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。<br>ZINCR生成一个zincr事件。<br>ZADD生成一个zadd事件，即使添加了多个元素。<br>ZREM生成一个zrem事件，即使删除了多个元素。当结果有序集合为空且生成了键，则会生成额外的del事件。<br>ZREMBYSCORE生成一个zrembyscore事件。当结果有序集合为空且生成了键，则会生成额外的del事件。<br>ZREMBYRANK生成一个zrembyrank事件。当结果有序集合为空且生成了键，则会生成额外的del事件。<br>ZINTERSTORE和ZUNIONSTORE分别生成zinterstore和zunionstore事件。在特殊情况下，结果有序集合是空的，并且存储结果的键已经存在，因为删除了键，所以会生成del事件。<br>每次一个拥有过期时间的键由于过期而从数据集中移除时，将生成一个expired事件。<br>每次一个键由于maxmemory策略而被从数据集中驱逐，以便释放内存时，将生成一个evicted事件。<br>重要 所有命令仅在真正修改目标键时才生成事件。例如，使用SREM命令从集合中删除一个不存在的元素将不会改变键的值，因此不会生成任何事件。如果对某个命令如何生成事件有疑问，最简单的方法是自己观察：’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config set notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe &#39;__key*__:*&#39;</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">&quot;psubscribe&quot;,&quot;__key*__:*&quot;,1</span><br></pre></td></tr></table></figure><p>此时，在另外一个终端使用redis-cli发送命令到Redis服务器，并观察生成的事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyspace@0__:foo&quot;,&quot;set&quot;</span><br><span class="line">&quot;pmessage&quot;,&quot;__key*__:*&quot;,&quot;__keyevent@0__:set&quot;,&quot;foo&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;功能概述&quot;&gt;&lt;a href=&quot;#功能概述&quot; class=&quot;headerlink&quot; title=&quot;功能概述&quot;&gt;&lt;/a&gt;功能概述&lt;/h3&gt;&lt;p&gt;键空间通知允许客户端订阅发布/订阅频道，以便以某种方式接收影响Redis数据集的事件。可能接收的事件示例如下：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>redis发布者订阅者</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/redis%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/redis%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/</id>
    <published>2021-03-19T07:16:18.880Z</published>
    <updated>2021-03-19T07:16:19.442Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="关系"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="关系"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例演示了发布订阅是如何工作的，需要开启两个 redis-cli 客户端。</p><p>在我们实例中我们创建了订阅频道名为 runoobChat:</p><p>第一个客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 runoobChat 发布两次消息，订阅者就能接收到消息。</p><p>第二个客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 订阅者的客户端会显示如下消息</span><br><span class="line"> 1) &quot;message&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) &quot;Redis PUBLISH test&quot;</span><br><span class="line"> 1) &quot;message&quot;</span><br><span class="line">2) &quot;runoobChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br></pre></td></tr></table></figure><p>下面还有redis发布订阅的指令</p><p>1    PSUBSCRIBE pattern [pattern …]</p><p>订阅一个或多个符合给定模式的频道。</p><p>2    PUBSUB subcommand [argument [argument …]]</p><p>查看订阅与发布系统状态。</p><p>3    PUBLISH channel message</p><p>将信息发送到指定的频道。</p><p>4    PUNSUBSCRIBE [pattern [pattern …]]</p><p>退订所有给定模式的频道。</p><p>5    SUBSCRIBE channel [channel …]</p><p>订阅给定的一个或多个频道的信息。</p><p>6    UNSUBSCRIBE [channel [channel …]]</p><p>指退订给定的频道。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。&lt;/p&gt;
&lt;p&gt;Redis 客户端可以订阅任意数量的频道。&lt;/p&gt;
&lt;p&gt;下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— cl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python向七牛云和又拍云上传文件</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/python%E5%90%91%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/python%E5%90%91%E4%B8%83%E7%89%9B%E4%BA%91%E5%92%8C%E5%8F%88%E6%8B%8D%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/</id>
    <published>2021-03-19T07:16:18.877Z</published>
    <updated>2021-03-19T07:16:20.703Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>---title: python向七牛云和又拍云上传文件---<h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>七牛云官方文档：<a href="https://developer.qiniu.com/kodo/1242/python#rs-stat" target="_blank" rel="noopener">https://developer.qiniu.com/kodo/1242/python#rs-stat</a></p><p>首先安装七牛云的官方模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接安装</span><br><span class="line">pip install qiniu</span><br><span class="line">或</span><br><span class="line">easy_install qiniu</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 源码安装</span><br><span class="line"># 从Python SDK 下载地址下载源码</span><br><span class="line">tar xvzf python-sdk-$VERSION.tar.gz</span><br><span class="line">cd python-sdk-$VERSION</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>定义七牛云对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from qiniu import Auth</span><br><span class="line">q &#x3D; Auth(access_key, secret_key)</span><br><span class="line"></span><br><span class="line"># access_key 和 secret_key 可以在你的七牛云个人中心中找到</span><br></pre></td></tr></table></figure><p><img src="../images/AK%E5%92%8CSK.PNG" alt="AK和SK"></p><p>开始上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key &#x3D; &#39;上传后的文件名&#39;</span><br><span class="line">bucket_name &#x3D; &#39;要上传的空间&#39;</span><br><span class="line">s &#x3D; 3600 # 指定token过期时间(秒)</span><br><span class="line"></span><br><span class="line">token &#x3D; q.upload_token(bucket_name, key, )</span><br><span class="line"></span><br><span class="line">localfile &#x3D; &#39;本地文件路径&#39;</span><br><span class="line"></span><br><span class="line">ret, info &#x3D; put_file(token, key, localfile)</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure><h3 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h3><p>又拍云官方文档： <a href="http://docs.upyun.com/api/sdk/#python-sdk" target="_blank" rel="noopener">http://docs.upyun.com/api/sdk/#python-sdk</a></p><p>安装又拍云官方模块</p><p><code>pip install upyun</code></p><p>初始化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 包含文件</span><br><span class="line">import upyun</span><br><span class="line"></span><br><span class="line"># 创建实例</span><br><span class="line">up &#x3D; upyun.UpYun(&#39;仓库名&#39;, &#39;您的操作员名&#39;, &#39;您的操作员密码&#39;)</span><br></pre></td></tr></table></figure><p><img src="../images/%E5%8F%88%E6%8B%8D%E4%BA%91%E6%93%8D%E4%BD%9C%E5%91%98.PNG" alt="操作员"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">* 参数说明</span><br><span class="line">* checksum，表示是否进行 MD5 校验，如果是小文件，建议进行，为 True；如果是大文件，建议不进行，为 False</span><br><span class="line">* headers，表示需要的头信息，见 REST API 上传文件</span><br><span class="line">*&#x2F;</span><br><span class="line">headers &#x3D; &#123; &#39;x-gmkerl-thumb&#39;: &#39;&#x2F;fw&#x2F;300&#39; &#125;</span><br><span class="line"></span><br><span class="line">with open(&#39;文件地址&#39;, &#39;rb&#39;) as f:</span><br><span class="line">    res &#x3D; up.put(&#39;存到仓库的位置和文件名&#39;, f, checksum&#x3D;True, headers&#x3D;headers)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
---
title: python向七牛云和又拍云上传文件
---


&lt;h3 id=&quot;七牛云&quot;&gt;&lt;a href=&quot;#七牛云&quot; class=&quot;headerlink&quot; title=&quot;七牛云&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/docker/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/docker/</id>
    <published>2021-03-19T07:16:18.872Z</published>
    <updated>2021-03-19T07:16:19.436Z</updated>
    
    <content type="html"><![CDATA[<p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>卸载旧版本</p><p><code>yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine</code></p><p>安装依赖包</p><p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p>安装docker</p><p><code>yum install docker-ce</code></p><p>启动docker</p><p><code>systemctl start docker</code></p><p>下载镜像</p><p><code>docker pull centos</code></p><p>运行容器</p><p><code>docker run centos echo &quot;hello word&quot;</code></p><p>运行容器指定容器</p><p><code>docker run hello-world</code></p><p>镜像加速<br>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。</p><p>Docker国内镜像：</p><p>网易加速器：<a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a><br>官方中国加速器：<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a><br>ustc的镜像：<a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a><br>也可使用私人镜像加速器地址，如使用阿里云的镜像加速器：登录阿里云-&gt;产品-&gt;搜索”容器镜像服务”-&gt;镜像库-&gt;镜像加速器。</p><p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 来配置 Daemon。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;docker&#x2F;daemon.json </span><br><span class="line">&#123; </span><br><span class="line">　　&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置成功后，CentOS重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload     #重启加速配置文件</span><br><span class="line">systemctl restart docker    #重启docker后台服务</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装依赖&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>celery异步</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/celery%E5%BC%82%E6%AD%A5/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/celery%E5%BC%82%E6%AD%A5/</id>
    <published>2021-03-19T07:16:18.870Z</published>
    <updated>2021-03-19T07:16:19.430Z</updated>
    
    <content type="html"><![CDATA[<p>安装celery</p><p><code>pip install celery</code></p><p>导入celery</p><p><code>from celery import Celery</code></p><p>启动celery</p><p><code>celery worker -A _tasks.tasks -l info -E</code></p><p>定义celery对象</p><p><code>app = Celery(&quot;taks&quot;, broker=&quot;redis://localhost/1&quot;)</code></p><p>定义队列方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.task()</span><br><span class="line">def function():</span><br><span class="line">    print(&quot;我是队列方法&quot;)</span><br></pre></td></tr></table></figure><p>调用</p><p><code>function()</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装celery&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install celery&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导入celery&lt;/p&gt;
&lt;p&gt;&lt;code&gt;from celery import Celery&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动celery&lt;/p&gt;
&lt;p&gt;&lt;cod
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>axios封装</title>
    <link href="https://github.com/wisdomowl704/owlboke/2021/03/19/axios%E5%B0%81%E8%A3%85/"/>
    <id>https://github.com/wisdomowl704/owlboke/2021/03/19/axios%E5%B0%81%E8%A3%85/</id>
    <published>2021-03-19T07:16:18.867Z</published>
    <updated>2021-03-19T07:16:19.433Z</updated>
    
    <content type="html"><![CDATA[<p>首先安装axios</p><p><code>npm install axios --save</code></p><p>导入axios</p><p><code>const axios = require(&#39;axios&#39;)</code></p><p>配置axios</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;&#39;</span><br><span class="line">axios.defaults.timeout &#x3D; 10000</span><br></pre></td></tr></table></figure><p>封装axios的四种请求方式</p><p>GET</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export function get(url, params, headers) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios.get(url, &#123;params, headers&#125;).then(res &#x3D;&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function post(url, params, headers) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios.post(url, params, headers).then((res) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; debugger</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PUT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function put(url, params, headers) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios.put(url, params, headers).then((res) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; debugger</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DELETE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function del(url, params, headers) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        axios.delete(url, &#123;data: params, headers&#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;).catch((err) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; debugger</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(&#123;</span><br><span class="line">    url: &#39;index&#x2F;&#39;,</span><br><span class="line">    data</span><br><span class="line">&#125;).then().catch()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先安装axios&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install axios --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导入axios&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const axios = require(&amp;#39;axios&amp;#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
